<?xml version='1.0' encoding='ISO-8859-1' standalone='yes'?>
<tagfile>
  <compound kind="file">
    <name>ABObj.h</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/Minuit/</path>
    <filename>ABObj_8h</filename>
    <includes id="ABTypes_8h" name="ABTypes.h" local="yes" imported="no">Minuit/ABTypes.h</includes>
    <class kind="class">ABObj</class>
    <class kind="class">ABObj&lt; vec, LAVector, double &gt;</class>
    <class kind="class">ABObj&lt; sym, LASymMatrix, double &gt;</class>
    <member kind="function">
      <type>ABObj&lt; mt, M, T &gt;</type>
      <name>operator *</name>
      <anchor>a0</anchor>
      <arglist>(T f, const M &amp;obj)</arglist>
    </member>
    <member kind="function">
      <type>ABObj&lt; mt, M, T &gt;</type>
      <name>operator/</name>
      <anchor>a1</anchor>
      <arglist>(const M &amp;obj, T f)</arglist>
    </member>
    <member kind="function">
      <type>ABObj&lt; mt, M, T &gt;</type>
      <name>operator-</name>
      <anchor>a2</anchor>
      <arglist>(const M &amp;obj)</arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>ABProd.h</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/Minuit/</path>
    <filename>ABProd_8h</filename>
    <includes id="ABObj_8h" name="ABObj.h" local="yes" imported="no">Minuit/ABObj.h</includes>
    <class kind="class">ABProd</class>
    <member kind="function">
      <type>ABObj&lt; typename AlgebraicProdType&lt; atype, btype &gt;::Type, ABProd&lt; ABObj&lt; atype, A, T &gt;, ABObj&lt; btype, B, T &gt; &gt;, T &gt;</type>
      <name>operator *</name>
      <anchor>a0</anchor>
      <arglist>(const ABObj&lt; atype, A, T &gt; &amp;a, const ABObj&lt; btype, B, T &gt; &amp;b)</arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>ABSum.h</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/Minuit/</path>
    <filename>ABSum_8h</filename>
    <includes id="ABObj_8h" name="ABObj.h" local="yes" imported="no">Minuit/ABObj.h</includes>
    <class kind="class">ABSum</class>
    <member kind="function">
      <type>ABObj&lt; typename AlgebraicSumType&lt; atype, btype &gt;::Type, ABSum&lt; ABObj&lt; atype, A, T &gt;, ABObj&lt; btype, B, T &gt; &gt;, T &gt;</type>
      <name>operator+</name>
      <anchor>a0</anchor>
      <arglist>(const ABObj&lt; atype, A, T &gt; &amp;a, const ABObj&lt; btype, B, T &gt; &amp;b)</arglist>
    </member>
    <member kind="function">
      <type>ABObj&lt; typename AlgebraicSumType&lt; atype, btype &gt;::Type, ABSum&lt; ABObj&lt; atype, A, T &gt;, ABObj&lt; btype, B, T &gt; &gt;, T &gt;</type>
      <name>operator-</name>
      <anchor>a1</anchor>
      <arglist>(const ABObj&lt; atype, A, T &gt; &amp;a, const ABObj&lt; btype, B, T &gt; &amp;b)</arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>ABTypes.h</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/Minuit/</path>
    <filename>ABTypes_8h</filename>
    <class kind="class">gen</class>
    <class kind="class">sym</class>
    <class kind="class">vec</class>
    <class kind="class">AlgebraicSumType</class>
    <class kind="class">AlgebraicSumType&lt; T, T &gt;</class>
    <class kind="class">AlgebraicSumType&lt; vec, gen &gt;</class>
    <class kind="class">AlgebraicSumType&lt; gen, vec &gt;</class>
    <class kind="class">AlgebraicSumType&lt; vec, sym &gt;</class>
    <class kind="class">AlgebraicSumType&lt; sym, vec &gt;</class>
    <class kind="class">AlgebraicProdType</class>
    <class kind="class">AlgebraicProdType&lt; T, T &gt;</class>
    <class kind="class">AlgebraicProdType&lt; gen, gen &gt;</class>
    <class kind="class">AlgebraicProdType&lt; sym, sym &gt;</class>
    <class kind="class">AlgebraicProdType&lt; sym, gen &gt;</class>
    <class kind="class">AlgebraicProdType&lt; gen, sym &gt;</class>
    <class kind="class">AlgebraicProdType&lt; vec, gen &gt;</class>
    <class kind="class">AlgebraicProdType&lt; gen, vec &gt;</class>
    <class kind="class">AlgebraicProdType&lt; vec, sym &gt;</class>
    <class kind="class">AlgebraicProdType&lt; sym, vec &gt;</class>
  </compound>
  <compound kind="file">
    <name>AnalyticalGradientCalculator.cpp</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/src/</path>
    <filename>AnalyticalGradientCalculator_8cpp</filename>
    <includes id="AnalyticalGradientCalculator_8h" name="AnalyticalGradientCalculator.h" local="yes" imported="no">Minuit/AnalyticalGradientCalculator.h</includes>
    <includes id="FCNGradientBase_8h" name="FCNGradientBase.h" local="yes" imported="no">Minuit/FCNGradientBase.h</includes>
    <includes id="MnUserTransformation_8h" name="MnUserTransformation.h" local="yes" imported="no">Minuit/MnUserTransformation.h</includes>
    <includes id="FunctionGradient_8h" name="FunctionGradient.h" local="yes" imported="no">Minuit/FunctionGradient.h</includes>
    <includes id="MinimumParameters_8h" name="MinimumParameters.h" local="yes" imported="no">Minuit/MinimumParameters.h</includes>
    <includes id="MnMatrix_8h" name="MnMatrix.h" local="yes" imported="no">Minuit/MnMatrix.h</includes>
  </compound>
  <compound kind="file">
    <name>AnalyticalGradientCalculator.h</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/Minuit/</path>
    <filename>AnalyticalGradientCalculator_8h</filename>
    <includes id="GradientCalculator_8h" name="GradientCalculator.h" local="yes" imported="no">Minuit/GradientCalculator.h</includes>
    <class kind="class">AnalyticalGradientCalculator</class>
  </compound>
  <compound kind="file">
    <name>BasicFunctionGradient.h</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/Minuit/</path>
    <filename>BasicFunctionGradient_8h</filename>
    <includes id="MnMatrix_8h" name="MnMatrix.h" local="yes" imported="no">Minuit/MnMatrix.h</includes>
    <includes id="StackAllocator_8h" name="StackAllocator.h" local="yes" imported="no">Minuit/StackAllocator.h</includes>
    <class kind="class">BasicFunctionGradient</class>
  </compound>
  <compound kind="file">
    <name>BasicFunctionMinimum.h</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/Minuit/</path>
    <filename>BasicFunctionMinimum_8h</filename>
    <includes id="MinimumSeed_8h" name="MinimumSeed.h" local="yes" imported="no">Minuit/MinimumSeed.h</includes>
    <includes id="MinimumState_8h" name="MinimumState.h" local="yes" imported="no">Minuit/MinimumState.h</includes>
    <includes id="MnUserParameterState_8h" name="MnUserParameterState.h" local="yes" imported="no">Minuit/MnUserParameterState.h</includes>
    <includes id="MnUserTransformation_8h" name="MnUserTransformation.h" local="yes" imported="no">Minuit/MnUserTransformation.h</includes>
    <includes id="StackAllocator_8h" name="StackAllocator.h" local="yes" imported="no">Minuit/StackAllocator.h</includes>
    <class kind="class">BasicFunctionMinimum</class>
    <class kind="class">BasicFunctionMinimum::MnReachedCallLimit</class>
    <class kind="class">BasicFunctionMinimum::MnAboveMaxEdm</class>
  </compound>
  <compound kind="file">
    <name>BasicMinimumError.cpp</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/src/</path>
    <filename>BasicMinimumError_8cpp</filename>
    <includes id="BasicMinimumError_8h" name="BasicMinimumError.h" local="yes" imported="no">Minuit/BasicMinimumError.h</includes>
  </compound>
  <compound kind="file">
    <name>BasicMinimumError.h</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/Minuit/</path>
    <filename>BasicMinimumError_8h</filename>
    <includes id="MnMatrix_8h" name="MnMatrix.h" local="yes" imported="no">Minuit/MnMatrix.h</includes>
    <includes id="LaSum_8h" name="LaSum.h" local="yes" imported="no">Minuit/LaSum.h</includes>
    <includes id="StackAllocator_8h" name="StackAllocator.h" local="yes" imported="no">Minuit/StackAllocator.h</includes>
    <class kind="class">BasicMinimumError</class>
    <class kind="class">BasicMinimumError::MnNotPosDef</class>
    <class kind="class">BasicMinimumError::MnMadePosDef</class>
    <class kind="class">BasicMinimumError::MnHesseFailed</class>
    <class kind="class">BasicMinimumError::MnInvertFailed</class>
  </compound>
  <compound kind="file">
    <name>BasicMinimumParameters.h</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/Minuit/</path>
    <filename>BasicMinimumParameters_8h</filename>
    <includes id="MnMatrix_8h" name="MnMatrix.h" local="yes" imported="no">Minuit/MnMatrix.h</includes>
    <includes id="StackAllocator_8h" name="StackAllocator.h" local="yes" imported="no">Minuit/StackAllocator.h</includes>
    <class kind="class">BasicMinimumParameters</class>
  </compound>
  <compound kind="file">
    <name>BasicMinimumSeed.h</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/Minuit/</path>
    <filename>BasicMinimumSeed_8h</filename>
    <includes id="MinimumState_8h" name="MinimumState.h" local="yes" imported="no">Minuit/MinimumState.h</includes>
    <includes id="MinimumParameters_8h" name="MinimumParameters.h" local="yes" imported="no">Minuit/MinimumParameters.h</includes>
    <includes id="MinimumError_8h" name="MinimumError.h" local="yes" imported="no">Minuit/MinimumError.h</includes>
    <includes id="FunctionGradient_8h" name="FunctionGradient.h" local="yes" imported="no">Minuit/FunctionGradient.h</includes>
    <includes id="MnUserTransformation_8h" name="MnUserTransformation.h" local="yes" imported="no">Minuit/MnUserTransformation.h</includes>
    <includes id="StackAllocator_8h" name="StackAllocator.h" local="yes" imported="no">Minuit/StackAllocator.h</includes>
    <class kind="class">BasicMinimumSeed</class>
  </compound>
  <compound kind="file">
    <name>BasicMinimumState.h</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/Minuit/</path>
    <filename>BasicMinimumState_8h</filename>
    <includes id="MinimumParameters_8h" name="MinimumParameters.h" local="yes" imported="no">Minuit/MinimumParameters.h</includes>
    <includes id="MinimumError_8h" name="MinimumError.h" local="yes" imported="no">Minuit/MinimumError.h</includes>
    <includes id="FunctionGradient_8h" name="FunctionGradient.h" local="yes" imported="no">Minuit/FunctionGradient.h</includes>
    <includes id="StackAllocator_8h" name="StackAllocator.h" local="yes" imported="no">Minuit/StackAllocator.h</includes>
    <class kind="class">BasicMinimumState</class>
  </compound>
  <compound kind="file">
    <name>CombinedMinimizer.h</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/Minuit/</path>
    <filename>CombinedMinimizer_8h</filename>
    <includes id="ModularFunctionMinimizer_8h" name="ModularFunctionMinimizer.h" local="yes" imported="no">Minuit/ModularFunctionMinimizer.h</includes>
    <includes id="MnSeedGenerator_8h" name="MnSeedGenerator.h" local="yes" imported="no">Minuit/MnSeedGenerator.h</includes>
    <includes id="CombinedMinimumBuilder_8h" name="CombinedMinimumBuilder.h" local="yes" imported="no">Minuit/CombinedMinimumBuilder.h</includes>
    <class kind="class">CombinedMinimizer</class>
  </compound>
  <compound kind="file">
    <name>CombinedMinimumBuilder.cpp</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/src/</path>
    <filename>CombinedMinimumBuilder_8cpp</filename>
    <includes id="CombinedMinimumBuilder_8h" name="CombinedMinimumBuilder.h" local="yes" imported="no">Minuit/CombinedMinimumBuilder.h</includes>
    <includes id="FunctionMinimum_8h" name="FunctionMinimum.h" local="yes" imported="no">Minuit/FunctionMinimum.h</includes>
    <includes id="MnStrategy_8h" name="MnStrategy.h" local="yes" imported="no">Minuit/MnStrategy.h</includes>
  </compound>
  <compound kind="file">
    <name>CombinedMinimumBuilder.h</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/Minuit/</path>
    <filename>CombinedMinimumBuilder_8h</filename>
    <includes id="MinimumBuilder_8h" name="MinimumBuilder.h" local="yes" imported="no">Minuit/MinimumBuilder.h</includes>
    <includes id="VariableMetricMinimizer_8h" name="VariableMetricMinimizer.h" local="yes" imported="no">Minuit/VariableMetricMinimizer.h</includes>
    <includes id="SimplexMinimizer_8h" name="SimplexMinimizer.h" local="yes" imported="no">Minuit/SimplexMinimizer.h</includes>
    <class kind="class">CombinedMinimumBuilder</class>
  </compound>
  <compound kind="file">
    <name>config.h</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/</path>
    <filename>config_8h</filename>
    <member kind="define">
      <type>#define</type>
      <name>HAVE_DLFCN_H</name>
      <anchor>a0</anchor>
      <arglist></arglist>
    </member>
    <member kind="define">
      <type>#define</type>
      <name>PACKAGE</name>
      <anchor>a1</anchor>
      <arglist></arglist>
    </member>
    <member kind="define">
      <type>#define</type>
      <name>VERSION</name>
      <anchor>a2</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>ContoursError.h</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/Minuit/</path>
    <filename>ContoursError_8h</filename>
    <includes id="MinosError_8h" name="MinosError.h" local="yes" imported="no">Minuit/MinosError.h</includes>
    <class kind="class">ContoursError</class>
  </compound>
  <compound kind="file">
    <name>DavidonErrorUpdator.cpp</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/src/</path>
    <filename>DavidonErrorUpdator_8cpp</filename>
    <includes id="DavidonErrorUpdator_8h" name="DavidonErrorUpdator.h" local="yes" imported="no">Minuit/DavidonErrorUpdator.h</includes>
    <includes id="MinimumState_8h" name="MinimumState.h" local="yes" imported="no">Minuit/MinimumState.h</includes>
    <includes id="LaSum_8h" name="LaSum.h" local="yes" imported="no">Minuit/LaSum.h</includes>
    <includes id="LaProd_8h" name="LaProd.h" local="yes" imported="no">Minuit/LaProd.h</includes>
    <member kind="function">
      <type>double</type>
      <name>inner_product</name>
      <anchor>a0</anchor>
      <arglist>(const LAVector &amp;, const LAVector &amp;)</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>similarity</name>
      <anchor>a1</anchor>
      <arglist>(const LAVector &amp;, const LASymMatrix &amp;)</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>sum_of_elements</name>
      <anchor>a2</anchor>
      <arglist>(const LASymMatrix &amp;)</arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>DavidonErrorUpdator.h</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/Minuit/</path>
    <filename>DavidonErrorUpdator_8h</filename>
    <includes id="MinimumErrorUpdator_8h" name="MinimumErrorUpdator.h" local="yes" imported="no">Minuit/MinimumErrorUpdator.h</includes>
    <class kind="class">DavidonErrorUpdator</class>
  </compound>
  <compound kind="file">
    <name>FCNBase.h</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/Minuit/</path>
    <filename>FCNBase_8h</filename>
    <class kind="class">FCNBase</class>
  </compound>
  <compound kind="file">
    <name>FCNGradientBase.h</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/Minuit/</path>
    <filename>FCNGradientBase_8h</filename>
    <includes id="FCNBase_8h" name="FCNBase.h" local="yes" imported="no">Minuit/FCNBase.h</includes>
    <class kind="class">FCNGradientBase</class>
  </compound>
  <compound kind="file">
    <name>FunctionGradient.h</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/Minuit/</path>
    <filename>FunctionGradient_8h</filename>
    <includes id="MnRefCountedPointer_8h" name="MnRefCountedPointer.h" local="yes" imported="no">Minuit/MnRefCountedPointer.h</includes>
    <includes id="BasicFunctionGradient_8h" name="BasicFunctionGradient.h" local="yes" imported="no">Minuit/BasicFunctionGradient.h</includes>
    <class kind="class">FunctionGradient</class>
  </compound>
  <compound kind="file">
    <name>FunctionMinimizer.h</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/Minuit/</path>
    <filename>FunctionMinimizer_8h</filename>
    <class kind="class">FunctionMinimizer</class>
  </compound>
  <compound kind="file">
    <name>FunctionMinimum.h</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/Minuit/</path>
    <filename>FunctionMinimum_8h</filename>
    <includes id="BasicFunctionMinimum_8h" name="BasicFunctionMinimum.h" local="yes" imported="no">Minuit/BasicFunctionMinimum.h</includes>
    <class kind="class">FunctionMinimum</class>
    <class kind="class">FunctionMinimum::MnReachedCallLimit</class>
    <class kind="class">FunctionMinimum::MnAboveMaxEdm</class>
  </compound>
  <compound kind="file">
    <name>GradientCalculator.h</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/Minuit/</path>
    <filename>GradientCalculator_8h</filename>
    <class kind="class">GradientCalculator</class>
  </compound>
  <compound kind="file">
    <name>HessianGradientCalculator.cpp</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/src/</path>
    <filename>HessianGradientCalculator_8cpp</filename>
    <includes id="HessianGradientCalculator_8h" name="HessianGradientCalculator.h" local="yes" imported="no">Minuit/HessianGradientCalculator.h</includes>
    <includes id="InitialGradientCalculator_8h" name="InitialGradientCalculator.h" local="yes" imported="no">Minuit/InitialGradientCalculator.h</includes>
    <includes id="MnFcn_8h" name="MnFcn.h" local="yes" imported="no">Minuit/MnFcn.h</includes>
    <includes id="MnUserTransformation_8h" name="MnUserTransformation.h" local="yes" imported="no">Minuit/MnUserTransformation.h</includes>
    <includes id="MnMachinePrecision_8h" name="MnMachinePrecision.h" local="yes" imported="no">Minuit/MnMachinePrecision.h</includes>
    <includes id="MinimumParameters_8h" name="MinimumParameters.h" local="yes" imported="no">Minuit/MinimumParameters.h</includes>
    <includes id="FunctionGradient_8h" name="FunctionGradient.h" local="yes" imported="no">Minuit/FunctionGradient.h</includes>
    <includes id="MnStrategy_8h" name="MnStrategy.h" local="yes" imported="no">Minuit/MnStrategy.h</includes>
  </compound>
  <compound kind="file">
    <name>HessianGradientCalculator.h</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/Minuit/</path>
    <filename>HessianGradientCalculator_8h</filename>
    <includes id="GradientCalculator_8h" name="GradientCalculator.h" local="yes" imported="no">Minuit/GradientCalculator.h</includes>
    <includes id="MnMatrix_8h" name="MnMatrix.h" local="yes" imported="no">Minuit/MnMatrix.h</includes>
    <class kind="class">HessianGradientCalculator</class>
  </compound>
  <compound kind="file">
    <name>InitialGradientCalculator.cpp</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/src/</path>
    <filename>InitialGradientCalculator_8cpp</filename>
    <includes id="InitialGradientCalculator_8h" name="InitialGradientCalculator.h" local="yes" imported="no">Minuit/InitialGradientCalculator.h</includes>
    <includes id="MnFcn_8h" name="MnFcn.h" local="yes" imported="no">Minuit/MnFcn.h</includes>
    <includes id="MnUserTransformation_8h" name="MnUserTransformation.h" local="yes" imported="no">Minuit/MnUserTransformation.h</includes>
    <includes id="MnMachinePrecision_8h" name="MnMachinePrecision.h" local="yes" imported="no">Minuit/MnMachinePrecision.h</includes>
    <includes id="MinimumParameters_8h" name="MinimumParameters.h" local="yes" imported="no">Minuit/MinimumParameters.h</includes>
    <includes id="FunctionGradient_8h" name="FunctionGradient.h" local="yes" imported="no">Minuit/FunctionGradient.h</includes>
    <includes id="MnStrategy_8h" name="MnStrategy.h" local="yes" imported="no">Minuit/MnStrategy.h</includes>
  </compound>
  <compound kind="file">
    <name>InitialGradientCalculator.h</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/Minuit/</path>
    <filename>InitialGradientCalculator_8h</filename>
    <includes id="GradientCalculator_8h" name="GradientCalculator.h" local="yes" imported="no">Minuit/GradientCalculator.h</includes>
    <class kind="class">InitialGradientCalculator</class>
  </compound>
  <compound kind="file">
    <name>LaEigenValues.cpp</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/src/</path>
    <filename>LaEigenValues_8cpp</filename>
    <includes id="LAVector_8h" name="LAVector.h" local="yes" imported="no">Minuit/LAVector.h</includes>
    <includes id="LASymMatrix_8h" name="LASymMatrix.h" local="yes" imported="no">Minuit/LASymMatrix.h</includes>
    <member kind="function">
      <type>int</type>
      <name>mneigen</name>
      <anchor>a0</anchor>
      <arglist>(double *, unsigned int, unsigned int, unsigned int, double *, double)</arglist>
    </member>
    <member kind="function">
      <type>LAVector</type>
      <name>eigenvalues</name>
      <anchor>a1</anchor>
      <arglist>(const LASymMatrix &amp;mat)</arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>LaInnerProduct.cpp</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/src/</path>
    <filename>LaInnerProduct_8cpp</filename>
    <includes id="LAVector_8h" name="LAVector.h" local="yes" imported="no">Minuit/LAVector.h</includes>
    <member kind="function">
      <type>double</type>
      <name>mnddot</name>
      <anchor>a0</anchor>
      <arglist>(unsigned int, const double *, int, const double *, int)</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>inner_product</name>
      <anchor>a1</anchor>
      <arglist>(const LAVector &amp;v1, const LAVector &amp;v2)</arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>LaInverse.cpp</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/src/</path>
    <filename>LaInverse_8cpp</filename>
    <includes id="LaInverse_8h" name="LaInverse.h" local="yes" imported="no">Minuit/LaInverse.h</includes>
    <includes id="LASymMatrix_8h" name="LASymMatrix.h" local="yes" imported="no">Minuit/LASymMatrix.h</includes>
    <member kind="function">
      <type>int</type>
      <name>mnvert</name>
      <anchor>a0</anchor>
      <arglist>(LASymMatrix &amp;t)</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>invert</name>
      <anchor>a1</anchor>
      <arglist>(LASymMatrix &amp;t)</arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>LaInverse.h</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/Minuit/</path>
    <filename>LaInverse_8h</filename>
    <includes id="MatrixInverse_8h" name="MatrixInverse.h" local="yes" imported="no">Minuit/MatrixInverse.h</includes>
    <includes id="LASymMatrix_8h" name="LASymMatrix.h" local="yes" imported="no">Minuit/LASymMatrix.h</includes>
    <member kind="function">
      <type>ABObj&lt; sym, MatrixInverse&lt; sym, ABObj&lt; sym, LASymMatrix, double &gt;, double &gt;, double &gt;</type>
      <name>inverse</name>
      <anchor>a0</anchor>
      <arglist>(const ABObj&lt; sym, LASymMatrix, double &gt; &amp;obj)</arglist>
    </member>
    <member kind="function">
      <type>ABObj&lt; sym, MatrixInverse&lt; sym, ABObj&lt; sym, LASymMatrix, double &gt;, double &gt;, double &gt;</type>
      <name>operator *</name>
      <anchor>a1</anchor>
      <arglist>(T f, const ABObj&lt; sym, MatrixInverse&lt; sym, ABObj&lt; sym, LASymMatrix, double &gt;, double &gt;, double &gt; &amp;inv)</arglist>
    </member>
    <member kind="function">
      <type>ABObj&lt; sym, MatrixInverse&lt; sym, ABObj&lt; sym, LASymMatrix, double &gt;, double &gt;, double &gt;</type>
      <name>operator/</name>
      <anchor>a2</anchor>
      <arglist>(const ABObj&lt; sym, MatrixInverse&lt; sym, ABObj&lt; sym, LASymMatrix, double &gt;, double &gt;, double &gt; &amp;inv, T f)</arglist>
    </member>
    <member kind="function">
      <type>ABObj&lt; sym, MatrixInverse&lt; sym, ABObj&lt; sym, LASymMatrix, double &gt;, double &gt;, double &gt;</type>
      <name>operator-</name>
      <anchor>a3</anchor>
      <arglist>(const ABObj&lt; sym, MatrixInverse&lt; sym, ABObj&lt; sym, LASymMatrix, double &gt;, double &gt;, double &gt; &amp;inv)</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>invert</name>
      <anchor>a4</anchor>
      <arglist>(LASymMatrix &amp;)</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>invert_undef_sym</name>
      <anchor>a5</anchor>
      <arglist>(LASymMatrix &amp;)</arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>LaOuterProduct.cpp</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/src/</path>
    <filename>LaOuterProduct_8cpp</filename>
    <includes id="LaOuterProduct_8h" name="LaOuterProduct.h" local="yes" imported="no">Minuit/LaOuterProduct.h</includes>
    <includes id="LAVector_8h" name="LAVector.h" local="yes" imported="no">Minuit/LAVector.h</includes>
    <includes id="LASymMatrix_8h" name="LASymMatrix.h" local="yes" imported="no">Minuit/LASymMatrix.h</includes>
    <member kind="function">
      <type>int</type>
      <name>mndspr</name>
      <anchor>a0</anchor>
      <arglist>(const char *, unsigned int, double, const double *, int, double *)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>outer_prod</name>
      <anchor>a1</anchor>
      <arglist>(LASymMatrix &amp;A, const LAVector &amp;v, double f)</arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>LaOuterProduct.h</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/Minuit/</path>
    <filename>LaOuterProduct_8h</filename>
    <includes id="VectorOuterProduct_8h" name="VectorOuterProduct.h" local="yes" imported="no">Minuit/VectorOuterProduct.h</includes>
    <includes id="ABSum_8h" name="ABSum.h" local="yes" imported="no">Minuit/ABSum.h</includes>
    <includes id="LAVector_8h" name="LAVector.h" local="yes" imported="no">Minuit/LAVector.h</includes>
    <includes id="LASymMatrix_8h" name="LASymMatrix.h" local="yes" imported="no">Minuit/LASymMatrix.h</includes>
    <member kind="function">
      <type>ABObj&lt; sym, VectorOuterProduct&lt; ABObj&lt; vec, LAVector, double &gt;, double &gt;, double &gt;</type>
      <name>outer_product</name>
      <anchor>a0</anchor>
      <arglist>(const ABObj&lt; vec, LAVector, double &gt; &amp;obj)</arglist>
    </member>
    <member kind="function">
      <type>ABObj&lt; sym, VectorOuterProduct&lt; ABObj&lt; vec, LAVector, T &gt;, T &gt;, T &gt;</type>
      <name>operator *</name>
      <anchor>a1</anchor>
      <arglist>(T f, const ABObj&lt; sym, VectorOuterProduct&lt; ABObj&lt; vec, LAVector, T &gt;, T &gt;, T &gt; &amp;obj)</arglist>
    </member>
    <member kind="function">
      <type>ABObj&lt; sym, VectorOuterProduct&lt; ABObj&lt; vec, LAVector, T &gt;, T &gt;, T &gt;</type>
      <name>operator/</name>
      <anchor>a2</anchor>
      <arglist>(const ABObj&lt; sym, VectorOuterProduct&lt; ABObj&lt; vec, LAVector, T &gt;, T &gt;, T &gt; &amp;obj, T f)</arglist>
    </member>
    <member kind="function">
      <type>ABObj&lt; sym, VectorOuterProduct&lt; ABObj&lt; vec, LAVector, T &gt;, T &gt;, T &gt;</type>
      <name>operator-</name>
      <anchor>a3</anchor>
      <arglist>(const ABObj&lt; sym, VectorOuterProduct&lt; ABObj&lt; vec, LAVector, T &gt;, T &gt;, T &gt; &amp;obj)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>outer_prod</name>
      <anchor>a4</anchor>
      <arglist>(LASymMatrix &amp;, const LAVector &amp;, double f=1.)</arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>LaProd.h</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/Minuit/</path>
    <filename>LaProd_8h</filename>
    <includes id="ABProd_8h" name="ABProd.h" local="yes" imported="no">Minuit/ABProd.h</includes>
    <includes id="LAVector_8h" name="LAVector.h" local="yes" imported="no">Minuit/LAVector.h</includes>
    <includes id="LASymMatrix_8h" name="LASymMatrix.h" local="yes" imported="no">Minuit/LASymMatrix.h</includes>
    <member kind="define">
      <type>#define</type>
      <name>OP_MULT1</name>
      <anchor>a0</anchor>
      <arglist>(MT1, MT2, MAT1, MAT2, T)</arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>LaSum.h</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/Minuit/</path>
    <filename>LaSum_8h</filename>
    <includes id="ABSum_8h" name="ABSum.h" local="yes" imported="no">Minuit/ABSum.h</includes>
    <includes id="LAVector_8h" name="LAVector.h" local="yes" imported="no">Minuit/LAVector.h</includes>
    <includes id="LASymMatrix_8h" name="LASymMatrix.h" local="yes" imported="no">Minuit/LASymMatrix.h</includes>
    <member kind="define">
      <type>#define</type>
      <name>OP_ADD1</name>
      <anchor>a0</anchor>
      <arglist>(MT, MAT1, T)</arglist>
    </member>
    <member kind="define">
      <type>#define</type>
      <name>OP_SCALE</name>
      <anchor>a1</anchor>
      <arglist>(MT, MAT1, T)</arglist>
    </member>
    <member kind="define">
      <type>#define</type>
      <name>OP_SCALE1</name>
      <anchor>a2</anchor>
      <arglist>(MT, MAT1, T)</arglist>
    </member>
    <member kind="define">
      <type>#define</type>
      <name>OP_MIN</name>
      <anchor>a3</anchor>
      <arglist>(MT, MAT1, T)</arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>LaSumOfElements.cpp</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/src/</path>
    <filename>LaSumOfElements_8cpp</filename>
    <includes id="LAVector_8h" name="LAVector.h" local="yes" imported="no">Minuit/LAVector.h</includes>
    <includes id="LASymMatrix_8h" name="LASymMatrix.h" local="yes" imported="no">Minuit/LASymMatrix.h</includes>
    <member kind="function">
      <type>double</type>
      <name>mndasum</name>
      <anchor>a0</anchor>
      <arglist>(unsigned int, const double *, int)</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>sum_of_elements</name>
      <anchor>a1</anchor>
      <arglist>(const LAVector &amp;v)</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>sum_of_elements</name>
      <anchor>a2</anchor>
      <arglist>(const LASymMatrix &amp;m)</arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>LASymMatrix.h</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/Minuit/</path>
    <filename>LASymMatrix_8h</filename>
    <includes id="ABSum_8h" name="ABSum.h" local="yes" imported="no">Minuit/ABSum.h</includes>
    <includes id="VectorOuterProduct_8h" name="VectorOuterProduct.h" local="yes" imported="no">Minuit/VectorOuterProduct.h</includes>
    <includes id="MatrixInverse_8h" name="MatrixInverse.h" local="yes" imported="no">Minuit/MatrixInverse.h</includes>
    <includes id="StackAllocator_8h" name="StackAllocator.h" local="yes" imported="no">Minuit/StackAllocator.h</includes>
    <class kind="class">LASymMatrix</class>
    <member kind="function">
      <type>int</type>
      <name>mndaxpy</name>
      <anchor>a0</anchor>
      <arglist>(unsigned int, double, const double *, int, double *, int)</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>mndscal</name>
      <anchor>a1</anchor>
      <arglist>(unsigned int, double, double *, int)</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>invert</name>
      <anchor>a2</anchor>
      <arglist>(LASymMatrix &amp;)</arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>LAVector.h</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/Minuit/</path>
    <filename>LAVector_8h</filename>
    <includes id="ABSum_8h" name="ABSum.h" local="yes" imported="no">Minuit/ABSum.h</includes>
    <includes id="ABProd_8h" name="ABProd.h" local="yes" imported="no">Minuit/ABProd.h</includes>
    <includes id="LASymMatrix_8h" name="LASymMatrix.h" local="yes" imported="no">Minuit/LASymMatrix.h</includes>
    <includes id="StackAllocator_8h" name="StackAllocator.h" local="yes" imported="no">Minuit/StackAllocator.h</includes>
    <class kind="class">LAVector</class>
    <member kind="function">
      <type>int</type>
      <name>mndaxpy</name>
      <anchor>a0</anchor>
      <arglist>(unsigned int, double, const double *, int, double *, int)</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>mndscal</name>
      <anchor>a1</anchor>
      <arglist>(unsigned int, double, double *, int)</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>mndspmv</name>
      <anchor>a2</anchor>
      <arglist>(const char *, unsigned const int, double, const double *, const double *, int, double, double *, int)</arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>LaVtMVSimilarity.cpp</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/src/</path>
    <filename>LaVtMVSimilarity_8cpp</filename>
    <includes id="LASymMatrix_8h" name="LASymMatrix.h" local="yes" imported="no">Minuit/LASymMatrix.h</includes>
    <includes id="LAVector_8h" name="LAVector.h" local="yes" imported="no">Minuit/LAVector.h</includes>
    <includes id="LaProd_8h" name="LaProd.h" local="yes" imported="no">Minuit/LaProd.h</includes>
    <member kind="function">
      <type>double</type>
      <name>mnddot</name>
      <anchor>a0</anchor>
      <arglist>(unsigned int, const double *, int, const double *, int)</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>similarity</name>
      <anchor>a1</anchor>
      <arglist>(const LAVector &amp;avec, const LASymMatrix &amp;mat)</arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>MatrixInverse.h</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/Minuit/</path>
    <filename>MatrixInverse_8h</filename>
    <includes id="ABTypes_8h" name="ABTypes.h" local="yes" imported="no">Minuit/ABTypes.h</includes>
    <includes id="ABObj_8h" name="ABObj.h" local="yes" imported="no">Minuit/ABObj.h</includes>
    <class kind="class">MatrixInverse</class>
    <class kind="class">MatrixInverse&lt; vec, M, T &gt;</class>
    <member kind="function">
      <type>ABObj&lt; mt, MatrixInverse&lt; mt, ABObj&lt; mt, M, T &gt;, T &gt;, T &gt;</type>
      <name>inverse</name>
      <anchor>a0</anchor>
      <arglist>(const ABObj&lt; mt, M, T &gt; &amp;obj)</arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>MinimumBuilder.h</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/Minuit/</path>
    <filename>MinimumBuilder_8h</filename>
    <class kind="class">MinimumBuilder</class>
  </compound>
  <compound kind="file">
    <name>MinimumError.h</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/Minuit/</path>
    <filename>MinimumError_8h</filename>
    <includes id="MnRefCountedPointer_8h" name="MnRefCountedPointer.h" local="yes" imported="no">Minuit/MnRefCountedPointer.h</includes>
    <includes id="BasicMinimumError_8h" name="BasicMinimumError.h" local="yes" imported="no">Minuit/BasicMinimumError.h</includes>
    <class kind="class">MinimumError</class>
    <class kind="class">MinimumError::MnNotPosDef</class>
    <class kind="class">MinimumError::MnMadePosDef</class>
    <class kind="class">MinimumError::MnHesseFailed</class>
    <class kind="class">MinimumError::MnInvertFailed</class>
  </compound>
  <compound kind="file">
    <name>MinimumErrorUpdator.h</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/Minuit/</path>
    <filename>MinimumErrorUpdator_8h</filename>
    <class kind="class">MinimumErrorUpdator</class>
  </compound>
  <compound kind="file">
    <name>MinimumParameters.h</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/Minuit/</path>
    <filename>MinimumParameters_8h</filename>
    <includes id="MnRefCountedPointer_8h" name="MnRefCountedPointer.h" local="yes" imported="no">Minuit/MnRefCountedPointer.h</includes>
    <includes id="BasicMinimumParameters_8h" name="BasicMinimumParameters.h" local="yes" imported="no">Minuit/BasicMinimumParameters.h</includes>
    <class kind="class">MinimumParameters</class>
  </compound>
  <compound kind="file">
    <name>MinimumSeed.h</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/Minuit/</path>
    <filename>MinimumSeed_8h</filename>
    <includes id="MnRefCountedPointer_8h" name="MnRefCountedPointer.h" local="yes" imported="no">Minuit/MnRefCountedPointer.h</includes>
    <includes id="BasicMinimumSeed_8h" name="BasicMinimumSeed.h" local="yes" imported="no">Minuit/BasicMinimumSeed.h</includes>
    <class kind="class">MinimumSeed</class>
  </compound>
  <compound kind="file">
    <name>MinimumSeedGenerator.h</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/Minuit/</path>
    <filename>MinimumSeedGenerator_8h</filename>
    <class kind="class">MinimumSeedGenerator</class>
  </compound>
  <compound kind="file">
    <name>MinimumState.h</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/Minuit/</path>
    <filename>MinimumState_8h</filename>
    <includes id="MnRefCountedPointer_8h" name="MnRefCountedPointer.h" local="yes" imported="no">Minuit/MnRefCountedPointer.h</includes>
    <includes id="BasicMinimumState_8h" name="BasicMinimumState.h" local="yes" imported="no">Minuit/BasicMinimumState.h</includes>
    <class kind="class">MinimumState</class>
  </compound>
  <compound kind="file">
    <name>MinosError.h</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/Minuit/</path>
    <filename>MinosError_8h</filename>
    <includes id="MnCross_8h" name="MnCross.h" local="yes" imported="no">Minuit/MnCross.h</includes>
    <class kind="class">MinosError</class>
  </compound>
  <compound kind="file">
    <name>MinuitParameter.h</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/Minuit/</path>
    <filename>MinuitParameter_8h</filename>
    <class kind="class">MinuitParameter</class>
  </compound>
  <compound kind="file">
    <name>MnApplication.cpp</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/src/</path>
    <filename>MnApplication_8cpp</filename>
    <includes id="MnApplication_8h" name="MnApplication.h" local="yes" imported="no">Minuit/MnApplication.h</includes>
    <includes id="FunctionMinimum_8h" name="FunctionMinimum.h" local="yes" imported="no">Minuit/FunctionMinimum.h</includes>
    <includes id="ModularFunctionMinimizer_8h" name="ModularFunctionMinimizer.h" local="yes" imported="no">Minuit/ModularFunctionMinimizer.h</includes>
  </compound>
  <compound kind="file">
    <name>MnApplication.h</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/Minuit/</path>
    <filename>MnApplication_8h</filename>
    <includes id="MnUserParameterState_8h" name="MnUserParameterState.h" local="yes" imported="no">Minuit/MnUserParameterState.h</includes>
    <includes id="MnStrategy_8h" name="MnStrategy.h" local="yes" imported="no">Minuit/MnStrategy.h</includes>
    <class kind="class">MnApplication</class>
  </compound>
  <compound kind="file">
    <name>mnbins.cpp</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/src/</path>
    <filename>mnbins_8cpp</filename>
    <member kind="function">
      <type>void</type>
      <name>mnbins</name>
      <anchor>a0</anchor>
      <arglist>(double a1, double a2, int naa, double &amp;bl, double &amp;bh, int &amp;nb, double &amp;bwid)</arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>MnContours.cpp</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/src/</path>
    <filename>MnContours_8cpp</filename>
    <includes id="MnContours_8h" name="MnContours.h" local="yes" imported="no">Minuit/MnContours.h</includes>
    <includes id="MnMinos_8h" name="MnMinos.h" local="yes" imported="no">Minuit/MnMinos.h</includes>
    <includes id="MnMigrad_8h" name="MnMigrad.h" local="yes" imported="no">Minuit/MnMigrad.h</includes>
    <includes id="MnFunctionCross_8h" name="MnFunctionCross.h" local="yes" imported="no">Minuit/MnFunctionCross.h</includes>
    <includes id="FunctionMinimum_8h" name="FunctionMinimum.h" local="yes" imported="no">Minuit/FunctionMinimum.h</includes>
    <includes id="FCNBase_8h" name="FCNBase.h" local="yes" imported="no">Minuit/FCNBase.h</includes>
    <includes id="MnCross_8h" name="MnCross.h" local="yes" imported="no">Minuit/MnCross.h</includes>
    <includes id="MinosError_8h" name="MinosError.h" local="yes" imported="no">Minuit/MinosError.h</includes>
    <includes id="ContoursError_8h" name="ContoursError.h" local="yes" imported="no">Minuit/ContoursError.h</includes>
  </compound>
  <compound kind="file">
    <name>MnContours.h</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/Minuit/</path>
    <filename>MnContours_8h</filename>
    <includes id="MnStrategy_8h" name="MnStrategy.h" local="yes" imported="no">Minuit/MnStrategy.h</includes>
    <class kind="class">MnContours</class>
  </compound>
  <compound kind="file">
    <name>MnCovarianceSqueeze.cpp</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/src/</path>
    <filename>MnCovarianceSqueeze_8cpp</filename>
    <includes id="MnCovarianceSqueeze_8h" name="MnCovarianceSqueeze.h" local="yes" imported="no">Minuit/MnCovarianceSqueeze.h</includes>
    <includes id="MnUserCovariance_8h" name="MnUserCovariance.h" local="yes" imported="no">Minuit/MnUserCovariance.h</includes>
    <includes id="MinimumError_8h" name="MinimumError.h" local="yes" imported="no">Minuit/MinimumError.h</includes>
  </compound>
  <compound kind="file">
    <name>MnCovarianceSqueeze.h</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/Minuit/</path>
    <filename>MnCovarianceSqueeze_8h</filename>
    <includes id="MnMatrix_8h" name="MnMatrix.h" local="yes" imported="no">Minuit/MnMatrix.h</includes>
    <class kind="class">MnCovarianceSqueeze</class>
  </compound>
  <compound kind="file">
    <name>MnCross.h</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/Minuit/</path>
    <filename>MnCross_8h</filename>
    <includes id="MnUserParameterState_8h" name="MnUserParameterState.h" local="yes" imported="no">Minuit/MnUserParameterState.h</includes>
    <class kind="class">MnCross</class>
    <class kind="class">MnCross::CrossParLimit</class>
    <class kind="class">MnCross::CrossFcnLimit</class>
    <class kind="class">MnCross::CrossNewMin</class>
  </compound>
  <compound kind="file">
    <name>mndasum.cpp</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/src/</path>
    <filename>mndasum_8cpp</filename>
    <member kind="function">
      <type>double</type>
      <name>mndasum</name>
      <anchor>a0</anchor>
      <arglist>(unsigned int n, const double *dx, int incx)</arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>mndaxpy.cpp</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/src/</path>
    <filename>mndaxpy_8cpp</filename>
    <member kind="function">
      <type>int</type>
      <name>mndaxpy</name>
      <anchor>a0</anchor>
      <arglist>(unsigned int n, double da, const double *dx, int incx, double *dy, int incy)</arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>mnddot.cpp</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/src/</path>
    <filename>mnddot_8cpp</filename>
    <member kind="function">
      <type>double</type>
      <name>mnddot</name>
      <anchor>a0</anchor>
      <arglist>(unsigned int n, const double *dx, int incx, const double *dy, int incy)</arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>mndscal.cpp</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/src/</path>
    <filename>mndscal_8cpp</filename>
    <member kind="function">
      <type>int</type>
      <name>mndscal</name>
      <anchor>a0</anchor>
      <arglist>(unsigned int n, double da, double *dx, int incx)</arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>mndspmv.cpp</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/src/</path>
    <filename>mndspmv_8cpp</filename>
    <member kind="function">
      <type>bool</type>
      <name>mnlsame</name>
      <anchor>a0</anchor>
      <arglist>(const char *, const char *)</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>mnxerbla</name>
      <anchor>a1</anchor>
      <arglist>(const char *, int)</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>mndspmv</name>
      <anchor>a2</anchor>
      <arglist>(const char *uplo, unsigned int n, double alpha, const double *ap, const double *x, int incx, double beta, double *y, int incy)</arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>mndspr.cpp</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/src/</path>
    <filename>mndspr_8cpp</filename>
    <member kind="function">
      <type>bool</type>
      <name>mnlsame</name>
      <anchor>a0</anchor>
      <arglist>(const char *, const char *)</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>mnxerbla</name>
      <anchor>a1</anchor>
      <arglist>(const char *, int)</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>mndspr</name>
      <anchor>a2</anchor>
      <arglist>(const char *uplo, unsigned int n, double alpha, const double *x, int incx, double *ap)</arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>MnEigen.cpp</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/src/</path>
    <filename>MnEigen_8cpp</filename>
    <includes id="MnEigen_8h" name="MnEigen.h" local="yes" imported="no">Minuit/MnEigen.h</includes>
    <includes id="MnUserCovariance_8h" name="MnUserCovariance.h" local="yes" imported="no">Minuit/MnUserCovariance.h</includes>
    <includes id="MnMatrix_8h" name="MnMatrix.h" local="yes" imported="no">Minuit/MnMatrix.h</includes>
    <member kind="function">
      <type>LAVector</type>
      <name>eigenvalues</name>
      <anchor>a0</anchor>
      <arglist>(const LASymMatrix &amp;)</arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>MnEigen.h</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/Minuit/</path>
    <filename>MnEigen_8h</filename>
    <class kind="class">MnEigen</class>
  </compound>
  <compound kind="file">
    <name>MnFcn.cpp</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/src/</path>
    <filename>MnFcn_8cpp</filename>
    <includes id="MnFcn_8h" name="MnFcn.h" local="yes" imported="no">Minuit/MnFcn.h</includes>
    <includes id="FCNBase_8h" name="FCNBase.h" local="yes" imported="no">Minuit/FCNBase.h</includes>
    <includes id="MnVectorTransform_8h" name="MnVectorTransform.h" local="yes" imported="no">Minuit/MnVectorTransform.h</includes>
  </compound>
  <compound kind="file">
    <name>MnFcn.h</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/Minuit/</path>
    <filename>MnFcn_8h</filename>
    <includes id="MnMatrix_8h" name="MnMatrix.h" local="yes" imported="no">Minuit/MnMatrix.h</includes>
    <class kind="class">MnFcn</class>
  </compound>
  <compound kind="file">
    <name>MnFunctionCross.cpp</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/src/</path>
    <filename>MnFunctionCross_8cpp</filename>
    <includes id="MnFunctionCross_8h" name="MnFunctionCross.h" local="yes" imported="no">Minuit/MnFunctionCross.h</includes>
    <includes id="FunctionMinimum_8h" name="FunctionMinimum.h" local="yes" imported="no">Minuit/FunctionMinimum.h</includes>
    <includes id="MnMigrad_8h" name="MnMigrad.h" local="yes" imported="no">Minuit/MnMigrad.h</includes>
    <includes id="FCNBase_8h" name="FCNBase.h" local="yes" imported="no">Minuit/FCNBase.h</includes>
    <includes id="MnParabola_8h" name="MnParabola.h" local="yes" imported="no">Minuit/MnParabola.h</includes>
    <includes id="MnParabolaPoint_8h" name="MnParabolaPoint.h" local="yes" imported="no">Minuit/MnParabolaPoint.h</includes>
    <includes id="MnParabolaFactory_8h" name="MnParabolaFactory.h" local="yes" imported="no">Minuit/MnParabolaFactory.h</includes>
    <includes id="MnCross_8h" name="MnCross.h" local="yes" imported="no">Minuit/MnCross.h</includes>
    <includes id="MnMachinePrecision_8h" name="MnMachinePrecision.h" local="yes" imported="no">Minuit/MnMachinePrecision.h</includes>
  </compound>
  <compound kind="file">
    <name>MnFunctionCross.h</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/Minuit/</path>
    <filename>MnFunctionCross_8h</filename>
    <class kind="class">MnFunctionCross</class>
  </compound>
  <compound kind="file">
    <name>MnGlobalCorrelationCoeff.cpp</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/src/</path>
    <filename>MnGlobalCorrelationCoeff_8cpp</filename>
    <includes id="MnGlobalCorrelationCoeff_8h" name="MnGlobalCorrelationCoeff.h" local="yes" imported="no">Minuit/MnGlobalCorrelationCoeff.h</includes>
  </compound>
  <compound kind="file">
    <name>MnGlobalCorrelationCoeff.h</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/Minuit/</path>
    <filename>MnGlobalCorrelationCoeff_8h</filename>
    <includes id="MnMatrix_8h" name="MnMatrix.h" local="yes" imported="no">Minuit/MnMatrix.h</includes>
    <class kind="class">MnGlobalCorrelationCoeff</class>
  </compound>
  <compound kind="file">
    <name>MnHesse.cpp</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/src/</path>
    <filename>MnHesse_8cpp</filename>
    <includes id="MnHesse_8h" name="MnHesse.h" local="yes" imported="no">Minuit/MnHesse.h</includes>
    <includes id="MnUserParameterState_8h" name="MnUserParameterState.h" local="yes" imported="no">Minuit/MnUserParameterState.h</includes>
    <includes id="MnUserFcn_8h" name="MnUserFcn.h" local="yes" imported="no">Minuit/MnUserFcn.h</includes>
    <includes id="FCNBase_8h" name="FCNBase.h" local="yes" imported="no">Minuit/FCNBase.h</includes>
    <includes id="MnPosDef_8h" name="MnPosDef.h" local="yes" imported="no">Minuit/MnPosDef.h</includes>
    <includes id="HessianGradientCalculator_8h" name="HessianGradientCalculator.h" local="yes" imported="no">Minuit/HessianGradientCalculator.h</includes>
    <includes id="Numerical2PGradientCalculator_8h" name="Numerical2PGradientCalculator.h" local="yes" imported="no">Minuit/Numerical2PGradientCalculator.h</includes>
    <includes id="InitialGradientCalculator_8h" name="InitialGradientCalculator.h" local="yes" imported="no">Minuit/InitialGradientCalculator.h</includes>
    <includes id="MinimumState_8h" name="MinimumState.h" local="yes" imported="no">Minuit/MinimumState.h</includes>
    <includes id="VariableMetricEDMEstimator_8h" name="VariableMetricEDMEstimator.h" local="yes" imported="no">Minuit/VariableMetricEDMEstimator.h</includes>
  </compound>
  <compound kind="file">
    <name>MnHesse.h</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/Minuit/</path>
    <filename>MnHesse_8h</filename>
    <includes id="MnStrategy_8h" name="MnStrategy.h" local="yes" imported="no">Minuit/MnStrategy.h</includes>
    <class kind="class">MnHesse</class>
  </compound>
  <compound kind="file">
    <name>MnLineSearch.cpp</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/src/</path>
    <filename>MnLineSearch_8cpp</filename>
    <includes id="MnLineSearch_8h" name="MnLineSearch.h" local="yes" imported="no">Minuit/MnLineSearch.h</includes>
    <includes id="MnFcn_8h" name="MnFcn.h" local="yes" imported="no">Minuit/MnFcn.h</includes>
    <includes id="MinimumParameters_8h" name="MinimumParameters.h" local="yes" imported="no">Minuit/MinimumParameters.h</includes>
    <includes id="MnMachinePrecision_8h" name="MnMachinePrecision.h" local="yes" imported="no">Minuit/MnMachinePrecision.h</includes>
    <includes id="MnParabola_8h" name="MnParabola.h" local="yes" imported="no">Minuit/MnParabola.h</includes>
    <includes id="MnParabolaPoint_8h" name="MnParabolaPoint.h" local="yes" imported="no">Minuit/MnParabolaPoint.h</includes>
    <includes id="MnParabolaFactory_8h" name="MnParabolaFactory.h" local="yes" imported="no">Minuit/MnParabolaFactory.h</includes>
    <includes id="LaSum_8h" name="LaSum.h" local="yes" imported="no">Minuit/LaSum.h</includes>
  </compound>
  <compound kind="file">
    <name>MnLineSearch.h</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/Minuit/</path>
    <filename>MnLineSearch_8h</filename>
    <includes id="MnMatrix_8h" name="MnMatrix.h" local="yes" imported="no">Minuit/MnMatrix.h</includes>
    <class kind="class">MnLineSearch</class>
  </compound>
  <compound kind="file">
    <name>mnlsame.cpp</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/src/</path>
    <filename>mnlsame_8cpp</filename>
    <member kind="function">
      <type>bool</type>
      <name>mnlsame</name>
      <anchor>a0</anchor>
      <arglist>(const char *ca, const char *cb)</arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>MnMachinePrecision.cpp</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/src/</path>
    <filename>MnMachinePrecision_8cpp</filename>
    <includes id="MnMachinePrecision_8h" name="MnMachinePrecision.h" local="yes" imported="no">Minuit/MnMachinePrecision.h</includes>
    <includes id="MnTiny_8h" name="MnTiny.h" local="yes" imported="no">Minuit/MnTiny.h</includes>
  </compound>
  <compound kind="file">
    <name>MnMachinePrecision.h</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/Minuit/</path>
    <filename>MnMachinePrecision_8h</filename>
    <class kind="class">MnMachinePrecision</class>
  </compound>
  <compound kind="file">
    <name>MnMatrix.h</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/Minuit/</path>
    <filename>MnMatrix_8h</filename>
    <includes id="LASymMatrix_8h" name="LASymMatrix.h" local="yes" imported="no">Minuit/LASymMatrix.h</includes>
    <includes id="LAVector_8h" name="LAVector.h" local="yes" imported="no">Minuit/LAVector.h</includes>
    <includes id="LaInverse_8h" name="LaInverse.h" local="yes" imported="no">Minuit/LaInverse.h</includes>
    <includes id="LaOuterProduct_8h" name="LaOuterProduct.h" local="yes" imported="no">Minuit/LaOuterProduct.h</includes>
    <member kind="typedef">
      <type>LASymMatrix</type>
      <name>MnAlgebraicSymMatrix</name>
      <anchor>a0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>LAVector</type>
      <name>MnAlgebraicVector</name>
      <anchor>a1</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>MnMigrad.h</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/Minuit/</path>
    <filename>MnMigrad_8h</filename>
    <includes id="MnApplication_8h" name="MnApplication.h" local="yes" imported="no">Minuit/MnApplication.h</includes>
    <includes id="VariableMetricMinimizer_8h" name="VariableMetricMinimizer.h" local="yes" imported="no">Minuit/VariableMetricMinimizer.h</includes>
    <class kind="class">MnMigrad</class>
  </compound>
  <compound kind="file">
    <name>MnMinimize.h</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/Minuit/</path>
    <filename>MnMinimize_8h</filename>
    <includes id="MnApplication_8h" name="MnApplication.h" local="yes" imported="no">Minuit/MnApplication.h</includes>
    <includes id="CombinedMinimizer_8h" name="CombinedMinimizer.h" local="yes" imported="no">Minuit/CombinedMinimizer.h</includes>
    <class kind="class">MnMinimize</class>
  </compound>
  <compound kind="file">
    <name>MnMinos.cpp</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/src/</path>
    <filename>MnMinos_8cpp</filename>
    <includes id="MnMinos_8h" name="MnMinos.h" local="yes" imported="no">Minuit/MnMinos.h</includes>
    <includes id="FunctionMinimum_8h" name="FunctionMinimum.h" local="yes" imported="no">Minuit/FunctionMinimum.h</includes>
    <includes id="FCNBase_8h" name="FCNBase.h" local="yes" imported="no">Minuit/FCNBase.h</includes>
    <includes id="MnFunctionCross_8h" name="MnFunctionCross.h" local="yes" imported="no">Minuit/MnFunctionCross.h</includes>
    <includes id="MnCross_8h" name="MnCross.h" local="yes" imported="no">Minuit/MnCross.h</includes>
    <includes id="MinosError_8h" name="MinosError.h" local="yes" imported="no">Minuit/MinosError.h</includes>
  </compound>
  <compound kind="file">
    <name>MnMinos.h</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/Minuit/</path>
    <filename>MnMinos_8h</filename>
    <includes id="MnStrategy_8h" name="MnStrategy.h" local="yes" imported="no">Minuit/MnStrategy.h</includes>
    <class kind="class">MnMinos</class>
  </compound>
  <compound kind="file">
    <name>MnParabola.h</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/Minuit/</path>
    <filename>MnParabola_8h</filename>
    <class kind="class">MnParabola</class>
  </compound>
  <compound kind="file">
    <name>MnParabolaFactory.cpp</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/src/</path>
    <filename>MnParabolaFactory_8cpp</filename>
    <includes id="MnParabolaFactory_8h" name="MnParabolaFactory.h" local="yes" imported="no">Minuit/MnParabolaFactory.h</includes>
    <includes id="MnParabola_8h" name="MnParabola.h" local="yes" imported="no">Minuit/MnParabola.h</includes>
    <includes id="MnParabolaPoint_8h" name="MnParabolaPoint.h" local="yes" imported="no">Minuit/MnParabolaPoint.h</includes>
  </compound>
  <compound kind="file">
    <name>MnParabolaFactory.h</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/Minuit/</path>
    <filename>MnParabolaFactory_8h</filename>
    <class kind="class">MnParabolaFactory</class>
  </compound>
  <compound kind="file">
    <name>MnParabolaPoint.h</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/Minuit/</path>
    <filename>MnParabolaPoint_8h</filename>
    <class kind="class">MnParabolaPoint</class>
  </compound>
  <compound kind="file">
    <name>MnParameterScan.cpp</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/src/</path>
    <filename>MnParameterScan_8cpp</filename>
    <includes id="MnParameterScan_8h" name="MnParameterScan.h" local="yes" imported="no">Minuit/MnParameterScan.h</includes>
    <includes id="FCNBase_8h" name="FCNBase.h" local="yes" imported="no">Minuit/FCNBase.h</includes>
  </compound>
  <compound kind="file">
    <name>MnParameterScan.h</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/Minuit/</path>
    <filename>MnParameterScan_8h</filename>
    <includes id="MnUserParameters_8h" name="MnUserParameters.h" local="yes" imported="no">Minuit/MnUserParameters.h</includes>
    <class kind="class">MnParameterScan</class>
  </compound>
  <compound kind="file">
    <name>MnPlot.cpp</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/src/</path>
    <filename>MnPlot_8cpp</filename>
    <includes id="MnPlot_8h" name="MnPlot.h" local="yes" imported="no">Minuit/MnPlot.h</includes>
    <member kind="function">
      <type>void</type>
      <name>mnplot</name>
      <anchor>a0</anchor>
      <arglist>(double *xpt, double *ypt, char *chpt, int nxypt, int npagwd, int npagln)</arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>MnPlot.h</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/Minuit/</path>
    <filename>MnPlot_8h</filename>
    <class kind="class">MnPlot</class>
  </compound>
  <compound kind="file">
    <name>MnPosDef.cpp</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/src/</path>
    <filename>MnPosDef_8cpp</filename>
    <includes id="MnPosDef_8h" name="MnPosDef.h" local="yes" imported="no">Minuit/MnPosDef.h</includes>
    <includes id="MinimumState_8h" name="MinimumState.h" local="yes" imported="no">Minuit/MinimumState.h</includes>
    <includes id="MnMachinePrecision_8h" name="MnMachinePrecision.h" local="yes" imported="no">Minuit/MnMachinePrecision.h</includes>
    <member kind="function">
      <type>LAVector</type>
      <name>eigenvalues</name>
      <anchor>a0</anchor>
      <arglist>(const LASymMatrix &amp;)</arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>MnPosDef.h</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/Minuit/</path>
    <filename>MnPosDef_8h</filename>
    <class kind="class">MnPosDef</class>
  </compound>
  <compound kind="file">
    <name>MnPrint.cpp</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/src/</path>
    <filename>MnPrint_8cpp</filename>
    <includes id="MnPrint_8h" name="MnPrint.h" local="yes" imported="no">Minuit/MnPrint.h</includes>
    <includes id="LAVector_8h" name="LAVector.h" local="yes" imported="no">Minuit/LAVector.h</includes>
    <includes id="LASymMatrix_8h" name="LASymMatrix.h" local="yes" imported="no">Minuit/LASymMatrix.h</includes>
    <includes id="FunctionMinimum_8h" name="FunctionMinimum.h" local="yes" imported="no">Minuit/FunctionMinimum.h</includes>
    <includes id="MnUserParameters_8h" name="MnUserParameters.h" local="yes" imported="no">Minuit/MnUserParameters.h</includes>
    <includes id="MnUserCovariance_8h" name="MnUserCovariance.h" local="yes" imported="no">Minuit/MnUserCovariance.h</includes>
    <includes id="MnGlobalCorrelationCoeff_8h" name="MnGlobalCorrelationCoeff.h" local="yes" imported="no">Minuit/MnGlobalCorrelationCoeff.h</includes>
    <includes id="MnUserParameterState_8h" name="MnUserParameterState.h" local="yes" imported="no">Minuit/MnUserParameterState.h</includes>
    <includes id="MinuitParameter_8h" name="MinuitParameter.h" local="yes" imported="no">Minuit/MinuitParameter.h</includes>
    <includes id="MnMachinePrecision_8h" name="MnMachinePrecision.h" local="yes" imported="no">Minuit/MnMachinePrecision.h</includes>
    <includes id="MinosError_8h" name="MinosError.h" local="yes" imported="no">Minuit/MinosError.h</includes>
    <includes id="ContoursError_8h" name="ContoursError.h" local="yes" imported="no">Minuit/ContoursError.h</includes>
    <includes id="MnPlot_8h" name="MnPlot.h" local="yes" imported="no">Minuit/MnPlot.h</includes>
    <member kind="function">
      <type>std::ostream &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>a0</anchor>
      <arglist>(std::ostream &amp;os, const LAVector &amp;vec)</arglist>
    </member>
    <member kind="function">
      <type>std::ostream &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>a1</anchor>
      <arglist>(std::ostream &amp;os, const LASymMatrix &amp;matrix)</arglist>
    </member>
    <member kind="function">
      <type>std::ostream &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>a2</anchor>
      <arglist>(std::ostream &amp;os, const MnUserParameters &amp;par)</arglist>
    </member>
    <member kind="function">
      <type>std::ostream &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>a3</anchor>
      <arglist>(std::ostream &amp;os, const MnUserCovariance &amp;matrix)</arglist>
    </member>
    <member kind="function">
      <type>std::ostream &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>a4</anchor>
      <arglist>(std::ostream &amp;os, const MnGlobalCorrelationCoeff &amp;coeff)</arglist>
    </member>
    <member kind="function">
      <type>std::ostream &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>a5</anchor>
      <arglist>(std::ostream &amp;os, const MnUserParameterState &amp;state)</arglist>
    </member>
    <member kind="function">
      <type>std::ostream &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>a6</anchor>
      <arglist>(std::ostream &amp;os, const FunctionMinimum &amp;min)</arglist>
    </member>
    <member kind="function">
      <type>std::ostream &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>a7</anchor>
      <arglist>(std::ostream &amp;os, const MinimumState &amp;min)</arglist>
    </member>
    <member kind="function">
      <type>std::ostream &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>a8</anchor>
      <arglist>(std::ostream &amp;os, const MnMachinePrecision &amp;prec)</arglist>
    </member>
    <member kind="function">
      <type>std::ostream &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>a9</anchor>
      <arglist>(std::ostream &amp;os, const MinosError &amp;me)</arglist>
    </member>
    <member kind="function">
      <type>std::ostream &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>a10</anchor>
      <arglist>(std::ostream &amp;os, const ContoursError &amp;ce)</arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>MnPrint.h</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/Minuit/</path>
    <filename>MnPrint_8h</filename>
    <member kind="function">
      <type>std::ostream &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>a0</anchor>
      <arglist>(std::ostream &amp;, const FunctionMinimum &amp;)</arglist>
    </member>
    <member kind="function">
      <type>std::ostream &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>a1</anchor>
      <arglist>(std::ostream &amp;, const MinimumState &amp;)</arglist>
    </member>
    <member kind="function">
      <type>std::ostream &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>a2</anchor>
      <arglist>(std::ostream &amp;, const LAVector &amp;)</arglist>
    </member>
    <member kind="function">
      <type>std::ostream &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>a3</anchor>
      <arglist>(std::ostream &amp;, const LASymMatrix &amp;)</arglist>
    </member>
    <member kind="function">
      <type>std::ostream &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>a4</anchor>
      <arglist>(std::ostream &amp;, const MnUserParameters &amp;)</arglist>
    </member>
    <member kind="function">
      <type>std::ostream &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>a5</anchor>
      <arglist>(std::ostream &amp;, const MnUserCovariance &amp;)</arglist>
    </member>
    <member kind="function">
      <type>std::ostream &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>a6</anchor>
      <arglist>(std::ostream &amp;, const MnGlobalCorrelationCoeff &amp;)</arglist>
    </member>
    <member kind="function">
      <type>std::ostream &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>a7</anchor>
      <arglist>(std::ostream &amp;, const MnUserParameterState &amp;)</arglist>
    </member>
    <member kind="function">
      <type>std::ostream &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>a8</anchor>
      <arglist>(std::ostream &amp;, const MnMachinePrecision &amp;)</arglist>
    </member>
    <member kind="function">
      <type>std::ostream &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>a9</anchor>
      <arglist>(std::ostream &amp;, const MinosError &amp;)</arglist>
    </member>
    <member kind="function">
      <type>std::ostream &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>a10</anchor>
      <arglist>(std::ostream &amp;, const ContoursError &amp;)</arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>MnRefCountedPointer.h</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/Minuit/</path>
    <filename>MnRefCountedPointer_8h</filename>
    <includes id="MnReferenceCounter_8h" name="MnReferenceCounter.h" local="yes" imported="no">MnReferenceCounter.h</includes>
    <class kind="class">MnRefCountedPointer</class>
  </compound>
  <compound kind="file">
    <name>MnReferenceCounter.h</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/Minuit/</path>
    <filename>MnReferenceCounter_8h</filename>
    <includes id="StackAllocator_8h" name="StackAllocator.h" local="yes" imported="no">StackAllocator.h</includes>
    <class kind="class">MnReferenceCounter</class>
  </compound>
  <compound kind="file">
    <name>MnScan.cpp</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/src/</path>
    <filename>MnScan_8cpp</filename>
    <includes id="MnScan_8h" name="MnScan.h" local="yes" imported="no">Minuit/MnScan.h</includes>
    <includes id="MnParameterScan_8h" name="MnParameterScan.h" local="yes" imported="no">Minuit/MnParameterScan.h</includes>
  </compound>
  <compound kind="file">
    <name>MnScan.h</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/Minuit/</path>
    <filename>MnScan_8h</filename>
    <includes id="MnApplication_8h" name="MnApplication.h" local="yes" imported="no">Minuit/MnApplication.h</includes>
    <includes id="ScanMinimizer_8h" name="ScanMinimizer.h" local="yes" imported="no">Minuit/ScanMinimizer.h</includes>
    <class kind="class">MnScan</class>
  </compound>
  <compound kind="file">
    <name>MnSeedGenerator.cpp</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/src/</path>
    <filename>MnSeedGenerator_8cpp</filename>
    <includes id="MnSeedGenerator_8h" name="MnSeedGenerator.h" local="yes" imported="no">Minuit/MnSeedGenerator.h</includes>
    <includes id="MinimumSeed_8h" name="MinimumSeed.h" local="yes" imported="no">Minuit/MinimumSeed.h</includes>
    <includes id="MnFcn_8h" name="MnFcn.h" local="yes" imported="no">Minuit/MnFcn.h</includes>
    <includes id="GradientCalculator_8h" name="GradientCalculator.h" local="yes" imported="no">Minuit/GradientCalculator.h</includes>
    <includes id="InitialGradientCalculator_8h" name="InitialGradientCalculator.h" local="yes" imported="no">Minuit/InitialGradientCalculator.h</includes>
    <includes id="MnUserTransformation_8h" name="MnUserTransformation.h" local="yes" imported="no">Minuit/MnUserTransformation.h</includes>
    <includes id="MinimumParameters_8h" name="MinimumParameters.h" local="yes" imported="no">Minuit/MinimumParameters.h</includes>
    <includes id="FunctionGradient_8h" name="FunctionGradient.h" local="yes" imported="no">Minuit/FunctionGradient.h</includes>
    <includes id="MinimumError_8h" name="MinimumError.h" local="yes" imported="no">Minuit/MinimumError.h</includes>
    <includes id="MnMatrix_8h" name="MnMatrix.h" local="yes" imported="no">Minuit/MnMatrix.h</includes>
    <includes id="MnMachinePrecision_8h" name="MnMachinePrecision.h" local="yes" imported="no">Minuit/MnMachinePrecision.h</includes>
    <includes id="MinuitParameter_8h" name="MinuitParameter.h" local="yes" imported="no">Minuit/MinuitParameter.h</includes>
    <includes id="MnLineSearch_8h" name="MnLineSearch.h" local="yes" imported="no">Minuit/MnLineSearch.h</includes>
    <includes id="MnParabolaPoint_8h" name="MnParabolaPoint.h" local="yes" imported="no">Minuit/MnParabolaPoint.h</includes>
    <includes id="MinimumState_8h" name="MinimumState.h" local="yes" imported="no">Minuit/MinimumState.h</includes>
    <includes id="MnUserParameterState_8h" name="MnUserParameterState.h" local="yes" imported="no">Minuit/MnUserParameterState.h</includes>
    <includes id="MnStrategy_8h" name="MnStrategy.h" local="yes" imported="no">Minuit/MnStrategy.h</includes>
    <includes id="MnHesse_8h" name="MnHesse.h" local="yes" imported="no">Minuit/MnHesse.h</includes>
    <includes id="VariableMetricEDMEstimator_8h" name="VariableMetricEDMEstimator.h" local="yes" imported="no">Minuit/VariableMetricEDMEstimator.h</includes>
    <includes id="NegativeG2LineSearch_8h" name="NegativeG2LineSearch.h" local="yes" imported="no">Minuit/NegativeG2LineSearch.h</includes>
    <includes id="AnalyticalGradientCalculator_8h" name="AnalyticalGradientCalculator.h" local="yes" imported="no">Minuit/AnalyticalGradientCalculator.h</includes>
    <includes id="Numerical2PGradientCalculator_8h" name="Numerical2PGradientCalculator.h" local="yes" imported="no">Minuit/Numerical2PGradientCalculator.h</includes>
    <includes id="HessianGradientCalculator_8h" name="HessianGradientCalculator.h" local="yes" imported="no">Minuit/HessianGradientCalculator.h</includes>
  </compound>
  <compound kind="file">
    <name>MnSeedGenerator.h</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/Minuit/</path>
    <filename>MnSeedGenerator_8h</filename>
    <includes id="MinimumSeedGenerator_8h" name="MinimumSeedGenerator.h" local="yes" imported="no">Minuit/MinimumSeedGenerator.h</includes>
    <class kind="class">MnSeedGenerator</class>
  </compound>
  <compound kind="file">
    <name>MnSimplex.h</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/Minuit/</path>
    <filename>MnSimplex_8h</filename>
    <includes id="MnApplication_8h" name="MnApplication.h" local="yes" imported="no">Minuit/MnApplication.h</includes>
    <includes id="SimplexMinimizer_8h" name="SimplexMinimizer.h" local="yes" imported="no">Minuit/SimplexMinimizer.h</includes>
    <class kind="class">MnSimplex</class>
  </compound>
  <compound kind="file">
    <name>MnStrategy.cpp</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/src/</path>
    <filename>MnStrategy_8cpp</filename>
    <includes id="MnStrategy_8h" name="MnStrategy.h" local="yes" imported="no">Minuit/MnStrategy.h</includes>
  </compound>
  <compound kind="file">
    <name>MnStrategy.h</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/Minuit/</path>
    <filename>MnStrategy_8h</filename>
    <class kind="class">MnStrategy</class>
  </compound>
  <compound kind="file">
    <name>mnteigen.cpp</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/src/</path>
    <filename>mnteigen_8cpp</filename>
    <member kind="function">
      <type>int</type>
      <name>mneigen</name>
      <anchor>a0</anchor>
      <arglist>(double *a, unsigned int ndima, unsigned int n, unsigned int mits, double *work, double precis)</arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>MnTimer.h</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/Minuit/</path>
    <filename>MnTimer_8h</filename>
    <class kind="class">MnTimer</class>
    <member kind="function">
      <type>unsigned long long int</type>
      <name>rdtscPentium</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>MnTiny.cpp</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/src/</path>
    <filename>MnTiny_8cpp</filename>
    <includes id="MnTiny_8h" name="MnTiny.h" local="yes" imported="no">Minuit/MnTiny.h</includes>
  </compound>
  <compound kind="file">
    <name>MnTiny.h</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/Minuit/</path>
    <filename>MnTiny_8h</filename>
    <class kind="class">MnTiny</class>
  </compound>
  <compound kind="file">
    <name>mntplot.cpp</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/src/</path>
    <filename>mntplot_8cpp</filename>
    <member kind="function">
      <type>void</type>
      <name>mnbins</name>
      <anchor>a0</anchor>
      <arglist>(double, double, int, double &amp;, double &amp;, int &amp;, double &amp;)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>mnplot</name>
      <anchor>a1</anchor>
      <arglist>(double *xpt, double *ypt, char *chpt, int nxypt, int npagwd, int npagln)</arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>MnUserCovariance.h</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/Minuit/</path>
    <filename>MnUserCovariance_8h</filename>
    <class kind="class">MnUserCovariance</class>
  </compound>
  <compound kind="file">
    <name>MnUserFcn.cpp</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/src/</path>
    <filename>MnUserFcn_8cpp</filename>
    <includes id="MnUserFcn_8h" name="MnUserFcn.h" local="yes" imported="no">Minuit/MnUserFcn.h</includes>
    <includes id="FCNBase_8h" name="FCNBase.h" local="yes" imported="no">Minuit/FCNBase.h</includes>
    <includes id="MnUserTransformation_8h" name="MnUserTransformation.h" local="yes" imported="no">Minuit/MnUserTransformation.h</includes>
  </compound>
  <compound kind="file">
    <name>MnUserFcn.h</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/Minuit/</path>
    <filename>MnUserFcn_8h</filename>
    <includes id="MnFcn_8h" name="MnFcn.h" local="yes" imported="no">Minuit/MnFcn.h</includes>
    <class kind="class">MnUserFcn</class>
  </compound>
  <compound kind="file">
    <name>MnUserParameters.cpp</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/src/</path>
    <filename>MnUserParameters_8cpp</filename>
    <includes id="MnUserParameters_8h" name="MnUserParameters.h" local="yes" imported="no">Minuit/MnUserParameters.h</includes>
  </compound>
  <compound kind="file">
    <name>MnUserParameters.h</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/Minuit/</path>
    <filename>MnUserParameters_8h</filename>
    <includes id="MnUserTransformation_8h" name="MnUserTransformation.h" local="yes" imported="no">Minuit/MnUserTransformation.h</includes>
    <class kind="class">MnUserParameters</class>
  </compound>
  <compound kind="file">
    <name>MnUserParameterState.cpp</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/src/</path>
    <filename>MnUserParameterState_8cpp</filename>
    <includes id="MnUserParameterState_8h" name="MnUserParameterState.h" local="yes" imported="no">Minuit/MnUserParameterState.h</includes>
    <includes id="MnCovarianceSqueeze_8h" name="MnCovarianceSqueeze.h" local="yes" imported="no">Minuit/MnCovarianceSqueeze.h</includes>
    <includes id="MinimumState_8h" name="MinimumState.h" local="yes" imported="no">Minuit/MinimumState.h</includes>
  </compound>
  <compound kind="file">
    <name>MnUserParameterState.h</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/Minuit/</path>
    <filename>MnUserParameterState_8h</filename>
    <includes id="MnUserParameters_8h" name="MnUserParameters.h" local="yes" imported="no">Minuit/MnUserParameters.h</includes>
    <includes id="MnUserCovariance_8h" name="MnUserCovariance.h" local="yes" imported="no">Minuit/MnUserCovariance.h</includes>
    <includes id="MnGlobalCorrelationCoeff_8h" name="MnGlobalCorrelationCoeff.h" local="yes" imported="no">Minuit/MnGlobalCorrelationCoeff.h</includes>
    <class kind="class">MnUserParameterState</class>
  </compound>
  <compound kind="file">
    <name>MnUserTransformation.cpp</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/src/</path>
    <filename>MnUserTransformation_8cpp</filename>
    <includes id="MnUserTransformation_8h" name="MnUserTransformation.h" local="yes" imported="no">Minuit/MnUserTransformation.h</includes>
    <includes id="MnUserCovariance_8h" name="MnUserCovariance.h" local="yes" imported="no">Minuit/MnUserCovariance.h</includes>
    <class kind="class">MnParStr</class>
  </compound>
  <compound kind="file">
    <name>MnUserTransformation.h</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/Minuit/</path>
    <filename>MnUserTransformation_8h</filename>
    <includes id="MnMatrix_8h" name="MnMatrix.h" local="yes" imported="no">Minuit/MnMatrix.h</includes>
    <includes id="MinuitParameter_8h" name="MinuitParameter.h" local="yes" imported="no">Minuit/MinuitParameter.h</includes>
    <includes id="MnMachinePrecision_8h" name="MnMachinePrecision.h" local="yes" imported="no">Minuit/MnMachinePrecision.h</includes>
    <includes id="SinParameterTransformation_8h" name="SinParameterTransformation.h" local="yes" imported="no">Minuit/SinParameterTransformation.h</includes>
    <includes id="SqrtLowParameterTransformation_8h" name="SqrtLowParameterTransformation.h" local="yes" imported="no">Minuit/SqrtLowParameterTransformation.h</includes>
    <includes id="SqrtUpParameterTransformation_8h" name="SqrtUpParameterTransformation.h" local="yes" imported="no">Minuit/SqrtUpParameterTransformation.h</includes>
    <class kind="class">MnUserTransformation</class>
  </compound>
  <compound kind="file">
    <name>MnVectorTransform.h</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/Minuit/</path>
    <filename>MnVectorTransform_8h</filename>
    <includes id="MnMatrix_8h" name="MnMatrix.h" local="yes" imported="no">Minuit/MnMatrix.h</includes>
    <class kind="class">MnVectorTransform</class>
  </compound>
  <compound kind="file">
    <name>mnvert.cpp</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/src/</path>
    <filename>mnvert_8cpp</filename>
    <includes id="MnMatrix_8h" name="MnMatrix.h" local="yes" imported="no">Minuit/MnMatrix.h</includes>
    <member kind="function">
      <type>int</type>
      <name>mnvert</name>
      <anchor>a0</anchor>
      <arglist>(MnAlgebraicSymMatrix &amp;a)</arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>mnxerbla.cpp</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/src/</path>
    <filename>mnxerbla_8cpp</filename>
    <member kind="function">
      <type>int</type>
      <name>mnxerbla</name>
      <anchor>a0</anchor>
      <arglist>(const char *srname, int info)</arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>ModularFunctionMinimizer.cpp</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/src/</path>
    <filename>ModularFunctionMinimizer_8cpp</filename>
    <includes id="ModularFunctionMinimizer_8h" name="ModularFunctionMinimizer.h" local="yes" imported="no">Minuit/ModularFunctionMinimizer.h</includes>
    <includes id="MinimumSeedGenerator_8h" name="MinimumSeedGenerator.h" local="yes" imported="no">Minuit/MinimumSeedGenerator.h</includes>
    <includes id="AnalyticalGradientCalculator_8h" name="AnalyticalGradientCalculator.h" local="yes" imported="no">Minuit/AnalyticalGradientCalculator.h</includes>
    <includes id="Numerical2PGradientCalculator_8h" name="Numerical2PGradientCalculator.h" local="yes" imported="no">Minuit/Numerical2PGradientCalculator.h</includes>
    <includes id="MinimumBuilder_8h" name="MinimumBuilder.h" local="yes" imported="no">Minuit/MinimumBuilder.h</includes>
    <includes id="MinimumSeed_8h" name="MinimumSeed.h" local="yes" imported="no">Minuit/MinimumSeed.h</includes>
    <includes id="FunctionMinimum_8h" name="FunctionMinimum.h" local="yes" imported="no">Minuit/FunctionMinimum.h</includes>
    <includes id="MnUserParameterState_8h" name="MnUserParameterState.h" local="yes" imported="no">Minuit/MnUserParameterState.h</includes>
    <includes id="MnUserParameters_8h" name="MnUserParameters.h" local="yes" imported="no">Minuit/MnUserParameters.h</includes>
    <includes id="MnUserCovariance_8h" name="MnUserCovariance.h" local="yes" imported="no">Minuit/MnUserCovariance.h</includes>
    <includes id="MnUserTransformation_8h" name="MnUserTransformation.h" local="yes" imported="no">Minuit/MnUserTransformation.h</includes>
    <includes id="MnUserFcn_8h" name="MnUserFcn.h" local="yes" imported="no">Minuit/MnUserFcn.h</includes>
    <includes id="FCNBase_8h" name="FCNBase.h" local="yes" imported="no">Minuit/FCNBase.h</includes>
    <includes id="FCNGradientBase_8h" name="FCNGradientBase.h" local="yes" imported="no">Minuit/FCNGradientBase.h</includes>
    <includes id="MnStrategy_8h" name="MnStrategy.h" local="yes" imported="no">Minuit/MnStrategy.h</includes>
    <includes id="MnHesse_8h" name="MnHesse.h" local="yes" imported="no">Minuit/MnHesse.h</includes>
    <includes id="MnLineSearch_8h" name="MnLineSearch.h" local="yes" imported="no">Minuit/MnLineSearch.h</includes>
    <includes id="MnParabolaPoint_8h" name="MnParabolaPoint.h" local="yes" imported="no">Minuit/MnParabolaPoint.h</includes>
  </compound>
  <compound kind="file">
    <name>ModularFunctionMinimizer.h</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/Minuit/</path>
    <filename>ModularFunctionMinimizer_8h</filename>
    <includes id="FunctionMinimizer_8h" name="FunctionMinimizer.h" local="yes" imported="no">Minuit/FunctionMinimizer.h</includes>
    <class kind="class">ModularFunctionMinimizer</class>
  </compound>
  <compound kind="file">
    <name>NegativeG2LineSearch.cpp</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/src/</path>
    <filename>NegativeG2LineSearch_8cpp</filename>
    <includes id="NegativeG2LineSearch_8h" name="NegativeG2LineSearch.h" local="yes" imported="no">Minuit/NegativeG2LineSearch.h</includes>
    <includes id="MnFcn_8h" name="MnFcn.h" local="yes" imported="no">Minuit/MnFcn.h</includes>
    <includes id="MinimumState_8h" name="MinimumState.h" local="yes" imported="no">Minuit/MinimumState.h</includes>
    <includes id="GradientCalculator_8h" name="GradientCalculator.h" local="yes" imported="no">Minuit/GradientCalculator.h</includes>
    <includes id="MnMachinePrecision_8h" name="MnMachinePrecision.h" local="yes" imported="no">Minuit/MnMachinePrecision.h</includes>
    <includes id="MnLineSearch_8h" name="MnLineSearch.h" local="yes" imported="no">Minuit/MnLineSearch.h</includes>
    <includes id="MnParabolaPoint_8h" name="MnParabolaPoint.h" local="yes" imported="no">Minuit/MnParabolaPoint.h</includes>
    <includes id="VariableMetricEDMEstimator_8h" name="VariableMetricEDMEstimator.h" local="yes" imported="no">Minuit/VariableMetricEDMEstimator.h</includes>
  </compound>
  <compound kind="file">
    <name>NegativeG2LineSearch.h</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/Minuit/</path>
    <filename>NegativeG2LineSearch_8h</filename>
    <class kind="class">NegativeG2LineSearch</class>
  </compound>
  <compound kind="file">
    <name>Numerical2PGradientCalculator.cpp</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/src/</path>
    <filename>Numerical2PGradientCalculator_8cpp</filename>
    <includes id="Numerical2PGradientCalculator_8h" name="Numerical2PGradientCalculator.h" local="yes" imported="no">Minuit/Numerical2PGradientCalculator.h</includes>
    <includes id="InitialGradientCalculator_8h" name="InitialGradientCalculator.h" local="yes" imported="no">Minuit/InitialGradientCalculator.h</includes>
    <includes id="MnFcn_8h" name="MnFcn.h" local="yes" imported="no">Minuit/MnFcn.h</includes>
    <includes id="MnUserTransformation_8h" name="MnUserTransformation.h" local="yes" imported="no">Minuit/MnUserTransformation.h</includes>
    <includes id="MnMachinePrecision_8h" name="MnMachinePrecision.h" local="yes" imported="no">Minuit/MnMachinePrecision.h</includes>
    <includes id="MinimumParameters_8h" name="MinimumParameters.h" local="yes" imported="no">Minuit/MinimumParameters.h</includes>
    <includes id="FunctionGradient_8h" name="FunctionGradient.h" local="yes" imported="no">Minuit/FunctionGradient.h</includes>
    <includes id="MnStrategy_8h" name="MnStrategy.h" local="yes" imported="no">Minuit/MnStrategy.h</includes>
  </compound>
  <compound kind="file">
    <name>Numerical2PGradientCalculator.h</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/Minuit/</path>
    <filename>Numerical2PGradientCalculator_8h</filename>
    <includes id="GradientCalculator_8h" name="GradientCalculator.h" local="yes" imported="no">Minuit/GradientCalculator.h</includes>
    <class kind="class">Numerical2PGradientCalculator</class>
  </compound>
  <compound kind="file">
    <name>ScanBuilder.cpp</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/src/</path>
    <filename>ScanBuilder_8cpp</filename>
    <includes id="ScanBuilder_8h" name="ScanBuilder.h" local="yes" imported="no">Minuit/ScanBuilder.h</includes>
    <includes id="MnParameterScan_8h" name="MnParameterScan.h" local="yes" imported="no">Minuit/MnParameterScan.h</includes>
    <includes id="FunctionMinimum_8h" name="FunctionMinimum.h" local="yes" imported="no">Minuit/FunctionMinimum.h</includes>
    <includes id="MinimumSeed_8h" name="MinimumSeed.h" local="yes" imported="no">Minuit/MinimumSeed.h</includes>
    <includes id="MinimumState_8h" name="MinimumState.h" local="yes" imported="no">Minuit/MinimumState.h</includes>
    <includes id="MnFcn_8h" name="MnFcn.h" local="yes" imported="no">Minuit/MnFcn.h</includes>
  </compound>
  <compound kind="file">
    <name>ScanBuilder.h</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/Minuit/</path>
    <filename>ScanBuilder_8h</filename>
    <includes id="MinimumBuilder_8h" name="MinimumBuilder.h" local="yes" imported="no">Minuit/MinimumBuilder.h</includes>
    <class kind="class">ScanBuilder</class>
  </compound>
  <compound kind="file">
    <name>ScanMinimizer.h</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/Minuit/</path>
    <filename>ScanMinimizer_8h</filename>
    <includes id="ModularFunctionMinimizer_8h" name="ModularFunctionMinimizer.h" local="yes" imported="no">Minuit/ModularFunctionMinimizer.h</includes>
    <includes id="ScanBuilder_8h" name="ScanBuilder.h" local="yes" imported="no">Minuit/ScanBuilder.h</includes>
    <includes id="SimplexSeedGenerator_8h" name="SimplexSeedGenerator.h" local="yes" imported="no">Minuit/SimplexSeedGenerator.h</includes>
    <class kind="class">ScanMinimizer</class>
  </compound>
  <compound kind="file">
    <name>SimplexBuilder.cpp</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/src/</path>
    <filename>SimplexBuilder_8cpp</filename>
    <includes id="SimplexBuilder_8h" name="SimplexBuilder.h" local="yes" imported="no">Minuit/SimplexBuilder.h</includes>
    <includes id="FunctionMinimum_8h" name="FunctionMinimum.h" local="yes" imported="no">Minuit/FunctionMinimum.h</includes>
    <includes id="MnFcn_8h" name="MnFcn.h" local="yes" imported="no">Minuit/MnFcn.h</includes>
    <includes id="MinimumSeed_8h" name="MinimumSeed.h" local="yes" imported="no">Minuit/MinimumSeed.h</includes>
    <includes id="SimplexParameters_8h" name="SimplexParameters.h" local="yes" imported="no">Minuit/SimplexParameters.h</includes>
    <includes id="MinimumState_8h" name="MinimumState.h" local="yes" imported="no">Minuit/MinimumState.h</includes>
  </compound>
  <compound kind="file">
    <name>SimplexBuilder.h</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/Minuit/</path>
    <filename>SimplexBuilder_8h</filename>
    <includes id="MinimumBuilder_8h" name="MinimumBuilder.h" local="yes" imported="no">Minuit/MinimumBuilder.h</includes>
    <class kind="class">SimplexBuilder</class>
  </compound>
  <compound kind="file">
    <name>SimplexMinimizer.h</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/Minuit/</path>
    <filename>SimplexMinimizer_8h</filename>
    <includes id="ModularFunctionMinimizer_8h" name="ModularFunctionMinimizer.h" local="yes" imported="no">Minuit/ModularFunctionMinimizer.h</includes>
    <includes id="SimplexBuilder_8h" name="SimplexBuilder.h" local="yes" imported="no">Minuit/SimplexBuilder.h</includes>
    <includes id="SimplexSeedGenerator_8h" name="SimplexSeedGenerator.h" local="yes" imported="no">Minuit/SimplexSeedGenerator.h</includes>
    <class kind="class">SimplexMinimizer</class>
  </compound>
  <compound kind="file">
    <name>SimplexParameters.cpp</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/src/</path>
    <filename>SimplexParameters_8cpp</filename>
    <includes id="SimplexParameters_8h" name="SimplexParameters.h" local="yes" imported="no">Minuit/SimplexParameters.h</includes>
  </compound>
  <compound kind="file">
    <name>SimplexParameters.h</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/Minuit/</path>
    <filename>SimplexParameters_8h</filename>
    <includes id="MnMatrix_8h" name="MnMatrix.h" local="yes" imported="no">Minuit/MnMatrix.h</includes>
    <class kind="class">SimplexParameters</class>
  </compound>
  <compound kind="file">
    <name>SimplexSeedGenerator.cpp</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/src/</path>
    <filename>SimplexSeedGenerator_8cpp</filename>
    <includes id="SimplexSeedGenerator_8h" name="SimplexSeedGenerator.h" local="yes" imported="no">Minuit/SimplexSeedGenerator.h</includes>
    <includes id="MnUserParameterState_8h" name="MnUserParameterState.h" local="yes" imported="no">Minuit/MnUserParameterState.h</includes>
    <includes id="MnFcn_8h" name="MnFcn.h" local="yes" imported="no">Minuit/MnFcn.h</includes>
    <includes id="MinimumSeed_8h" name="MinimumSeed.h" local="yes" imported="no">Minuit/MinimumSeed.h</includes>
    <includes id="MnStrategy_8h" name="MnStrategy.h" local="yes" imported="no">Minuit/MnStrategy.h</includes>
    <includes id="InitialGradientCalculator_8h" name="InitialGradientCalculator.h" local="yes" imported="no">Minuit/InitialGradientCalculator.h</includes>
    <includes id="VariableMetricEDMEstimator_8h" name="VariableMetricEDMEstimator.h" local="yes" imported="no">Minuit/VariableMetricEDMEstimator.h</includes>
  </compound>
  <compound kind="file">
    <name>SimplexSeedGenerator.h</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/Minuit/</path>
    <filename>SimplexSeedGenerator_8h</filename>
    <includes id="MinimumSeedGenerator_8h" name="MinimumSeedGenerator.h" local="yes" imported="no">Minuit/MinimumSeedGenerator.h</includes>
    <class kind="class">SimplexSeedGenerator</class>
  </compound>
  <compound kind="file">
    <name>SinParameterTransformation.cpp</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/src/</path>
    <filename>SinParameterTransformation_8cpp</filename>
    <includes id="SinParameterTransformation_8h" name="SinParameterTransformation.h" local="yes" imported="no">Minuit/SinParameterTransformation.h</includes>
    <includes id="MnMachinePrecision_8h" name="MnMachinePrecision.h" local="yes" imported="no">Minuit/MnMachinePrecision.h</includes>
  </compound>
  <compound kind="file">
    <name>SinParameterTransformation.h</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/Minuit/</path>
    <filename>SinParameterTransformation_8h</filename>
    <class kind="class">SinParameterTransformation</class>
  </compound>
  <compound kind="file">
    <name>SqrtLowParameterTransformation.cpp</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/src/</path>
    <filename>SqrtLowParameterTransformation_8cpp</filename>
    <includes id="SqrtLowParameterTransformation_8h" name="SqrtLowParameterTransformation.h" local="yes" imported="no">Minuit/SqrtLowParameterTransformation.h</includes>
    <includes id="MnMachinePrecision_8h" name="MnMachinePrecision.h" local="yes" imported="no">Minuit/MnMachinePrecision.h</includes>
  </compound>
  <compound kind="file">
    <name>SqrtLowParameterTransformation.h</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/Minuit/</path>
    <filename>SqrtLowParameterTransformation_8h</filename>
    <class kind="class">SqrtLowParameterTransformation</class>
    <member kind="define">
      <type>#define</type>
      <name>MINUIT_SQRTLOWPARAMETERTRANSFORMATION_H</name>
      <anchor>a0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>SqrtUpParameterTransformation.cpp</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/src/</path>
    <filename>SqrtUpParameterTransformation_8cpp</filename>
    <includes id="SqrtUpParameterTransformation_8h" name="SqrtUpParameterTransformation.h" local="yes" imported="no">Minuit/SqrtUpParameterTransformation.h</includes>
    <includes id="MnMachinePrecision_8h" name="MnMachinePrecision.h" local="yes" imported="no">Minuit/MnMachinePrecision.h</includes>
  </compound>
  <compound kind="file">
    <name>SqrtUpParameterTransformation.h</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/Minuit/</path>
    <filename>SqrtUpParameterTransformation_8h</filename>
    <class kind="class">SqrtUpParameterTransformation</class>
    <member kind="define">
      <type>#define</type>
      <name>MINUIT_SQRTUPPARAMETERTRANSFORMATION_H</name>
      <anchor>a0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>StackAllocator.h</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/Minuit/</path>
    <filename>StackAllocator_8h</filename>
    <class kind="class">StackOverflow</class>
    <class kind="class">StackError</class>
    <class kind="class">StackAllocator</class>
    <class kind="class">StackAllocatorHolder</class>
  </compound>
  <compound kind="file">
    <name>VariableMetricBuilder.cpp</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/src/</path>
    <filename>VariableMetricBuilder_8cpp</filename>
    <includes id="VariableMetricBuilder_8h" name="VariableMetricBuilder.h" local="yes" imported="no">Minuit/VariableMetricBuilder.h</includes>
    <includes id="GradientCalculator_8h" name="GradientCalculator.h" local="yes" imported="no">Minuit/GradientCalculator.h</includes>
    <includes id="MinimumState_8h" name="MinimumState.h" local="yes" imported="no">Minuit/MinimumState.h</includes>
    <includes id="MinimumError_8h" name="MinimumError.h" local="yes" imported="no">Minuit/MinimumError.h</includes>
    <includes id="FunctionGradient_8h" name="FunctionGradient.h" local="yes" imported="no">Minuit/FunctionGradient.h</includes>
    <includes id="FunctionMinimum_8h" name="FunctionMinimum.h" local="yes" imported="no">Minuit/FunctionMinimum.h</includes>
    <includes id="MnLineSearch_8h" name="MnLineSearch.h" local="yes" imported="no">Minuit/MnLineSearch.h</includes>
    <includes id="MinimumSeed_8h" name="MinimumSeed.h" local="yes" imported="no">Minuit/MinimumSeed.h</includes>
    <includes id="MnFcn_8h" name="MnFcn.h" local="yes" imported="no">Minuit/MnFcn.h</includes>
    <includes id="MnMachinePrecision_8h" name="MnMachinePrecision.h" local="yes" imported="no">Minuit/MnMachinePrecision.h</includes>
    <includes id="MnPosDef_8h" name="MnPosDef.h" local="yes" imported="no">Minuit/MnPosDef.h</includes>
    <includes id="MnParabolaPoint_8h" name="MnParabolaPoint.h" local="yes" imported="no">Minuit/MnParabolaPoint.h</includes>
    <includes id="LaSum_8h" name="LaSum.h" local="yes" imported="no">Minuit/LaSum.h</includes>
    <includes id="LaProd_8h" name="LaProd.h" local="yes" imported="no">Minuit/LaProd.h</includes>
    <includes id="MnStrategy_8h" name="MnStrategy.h" local="yes" imported="no">Minuit/MnStrategy.h</includes>
    <includes id="MnHesse_8h" name="MnHesse.h" local="yes" imported="no">Minuit/MnHesse.h</includes>
    <member kind="function">
      <type>double</type>
      <name>inner_product</name>
      <anchor>a0</anchor>
      <arglist>(const LAVector &amp;, const LAVector &amp;)</arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>VariableMetricBuilder.h</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/Minuit/</path>
    <filename>VariableMetricBuilder_8h</filename>
    <includes id="MinimumBuilder_8h" name="MinimumBuilder.h" local="yes" imported="no">Minuit/MinimumBuilder.h</includes>
    <includes id="VariableMetricEDMEstimator_8h" name="VariableMetricEDMEstimator.h" local="yes" imported="no">Minuit/VariableMetricEDMEstimator.h</includes>
    <includes id="DavidonErrorUpdator_8h" name="DavidonErrorUpdator.h" local="yes" imported="no">Minuit/DavidonErrorUpdator.h</includes>
    <class kind="class">VariableMetricBuilder</class>
  </compound>
  <compound kind="file">
    <name>VariableMetricEDMEstimator.cpp</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/src/</path>
    <filename>VariableMetricEDMEstimator_8cpp</filename>
    <includes id="VariableMetricEDMEstimator_8h" name="VariableMetricEDMEstimator.h" local="yes" imported="no">Minuit/VariableMetricEDMEstimator.h</includes>
    <includes id="FunctionGradient_8h" name="FunctionGradient.h" local="yes" imported="no">Minuit/FunctionGradient.h</includes>
    <includes id="MinimumError_8h" name="MinimumError.h" local="yes" imported="no">Minuit/MinimumError.h</includes>
    <member kind="function">
      <type>double</type>
      <name>similarity</name>
      <anchor>a0</anchor>
      <arglist>(const LAVector &amp;, const LASymMatrix &amp;)</arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>VariableMetricEDMEstimator.h</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/Minuit/</path>
    <filename>VariableMetricEDMEstimator_8h</filename>
    <class kind="class">VariableMetricEDMEstimator</class>
  </compound>
  <compound kind="file">
    <name>VariableMetricMinimizer.h</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/Minuit/</path>
    <filename>VariableMetricMinimizer_8h</filename>
    <includes id="ModularFunctionMinimizer_8h" name="ModularFunctionMinimizer.h" local="yes" imported="no">Minuit/ModularFunctionMinimizer.h</includes>
    <includes id="MnSeedGenerator_8h" name="MnSeedGenerator.h" local="yes" imported="no">Minuit/MnSeedGenerator.h</includes>
    <includes id="VariableMetricBuilder_8h" name="VariableMetricBuilder.h" local="yes" imported="no">Minuit/VariableMetricBuilder.h</includes>
    <class kind="class">VariableMetricMinimizer</class>
  </compound>
  <compound kind="file">
    <name>VectorOuterProduct.h</name>
    <path>/home1/anaphe/moneta/mathlib/Minuit/Minuit/</path>
    <filename>VectorOuterProduct_8h</filename>
    <includes id="ABTypes_8h" name="ABTypes.h" local="yes" imported="no">Minuit/ABTypes.h</includes>
    <includes id="ABObj_8h" name="ABObj.h" local="yes" imported="no">Minuit/ABObj.h</includes>
    <class kind="class">VectorOuterProduct</class>
    <member kind="function">
      <type>ABObj&lt; sym, VectorOuterProduct&lt; ABObj&lt; vec, M, T &gt;, T &gt;, T &gt;</type>
      <name>outer_product</name>
      <anchor>a0</anchor>
      <arglist>(const ABObj&lt; vec, M, T &gt; &amp;obj)</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ABObj</name>
    <filename>classABObj.html</filename>
    <templarg>mtype</templarg>
    <templarg>M</templarg>
    <templarg>T</templarg>
    <member kind="typedef">
      <type>mtype</type>
      <name>Type</name>
      <anchor>ABObjw0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ABObj</name>
      <anchor>ABObja0</anchor>
      <arglist>(const M &amp;obj)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ABObj</name>
      <anchor>ABObja1</anchor>
      <arglist>(const M &amp;obj, T factor)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~ABObj</name>
      <anchor>ABObja2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ABObj</name>
      <anchor>ABObja3</anchor>
      <arglist>(const ABObj &amp;obj)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ABObj</name>
      <anchor>ABObja4</anchor>
      <arglist>(const ABObj&lt; mtype, b, c &gt; &amp;obj)</arglist>
    </member>
    <member kind="function">
      <type>const M &amp;</type>
      <name>obj</name>
      <anchor>ABObja5</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>T</type>
      <name>f</name>
      <anchor>ABObja6</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="private">
      <type></type>
      <name>ABObj</name>
      <anchor>ABObjd0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>ABObj &amp;</type>
      <name>operator=</name>
      <anchor>ABObjd1</anchor>
      <arglist>(const ABObj &amp;)</arglist>
    </member>
    <member kind="function" protection="private">
      <type></type>
      <name>ABObj</name>
      <anchor>ABObjd2</anchor>
      <arglist>(const ABObj&lt; a, b, c &gt; &amp;obj)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>ABObj &amp;</type>
      <name>operator=</name>
      <anchor>ABObjd3</anchor>
      <arglist>(const ABObj&lt; a, b, c &gt; &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>M</type>
      <name>theObject</name>
      <anchor>ABObjr0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>T</type>
      <name>theFactor</name>
      <anchor>ABObjr1</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ABObj&lt; sym, LASymMatrix, double &gt;</name>
    <filename>classABObj_3_01sym_00_01LASymMatrix_00_01double_01_4.html</filename>
    <member kind="typedef">
      <type>sym</type>
      <name>Type</name>
      <anchor>ABObj_3_01sym_00_01LASymMatrix_00_01double_01_4w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ABObj</name>
      <anchor>ABObj_3_01sym_00_01LASymMatrix_00_01double_01_4a0</anchor>
      <arglist>(const LASymMatrix &amp;obj)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ABObj</name>
      <anchor>ABObj_3_01sym_00_01LASymMatrix_00_01double_01_4a1</anchor>
      <arglist>(const LASymMatrix &amp;obj, double factor)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~ABObj</name>
      <anchor>ABObj_3_01sym_00_01LASymMatrix_00_01double_01_4a2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ABObj</name>
      <anchor>ABObj_3_01sym_00_01LASymMatrix_00_01double_01_4a3</anchor>
      <arglist>(const ABObj &amp;obj)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ABObj</name>
      <anchor>ABObj_3_01sym_00_01LASymMatrix_00_01double_01_4a4</anchor>
      <arglist>(const ABObj&lt; vec, LASymMatrix, c &gt; &amp;obj)</arglist>
    </member>
    <member kind="function">
      <type>const LASymMatrix &amp;</type>
      <name>obj</name>
      <anchor>ABObj_3_01sym_00_01LASymMatrix_00_01double_01_4a5</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>f</name>
      <anchor>ABObj_3_01sym_00_01LASymMatrix_00_01double_01_4a6</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="private">
      <type>ABObj &amp;</type>
      <name>operator=</name>
      <anchor>ABObj_3_01sym_00_01LASymMatrix_00_01double_01_4d0</anchor>
      <arglist>(const ABObj &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>const LASymMatrix &amp;</type>
      <name>theObject</name>
      <anchor>ABObj_3_01sym_00_01LASymMatrix_00_01double_01_4r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theFactor</name>
      <anchor>ABObj_3_01sym_00_01LASymMatrix_00_01double_01_4r1</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ABObj&lt; vec, LAVector, double &gt;</name>
    <filename>classABObj_3_01vec_00_01LAVector_00_01double_01_4.html</filename>
    <member kind="typedef">
      <type>vec</type>
      <name>Type</name>
      <anchor>ABObj_3_01vec_00_01LAVector_00_01double_01_4w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ABObj</name>
      <anchor>ABObj_3_01vec_00_01LAVector_00_01double_01_4a0</anchor>
      <arglist>(const LAVector &amp;obj)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ABObj</name>
      <anchor>ABObj_3_01vec_00_01LAVector_00_01double_01_4a1</anchor>
      <arglist>(const LAVector &amp;obj, double factor)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~ABObj</name>
      <anchor>ABObj_3_01vec_00_01LAVector_00_01double_01_4a2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ABObj</name>
      <anchor>ABObj_3_01vec_00_01LAVector_00_01double_01_4a3</anchor>
      <arglist>(const ABObj &amp;obj)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ABObj</name>
      <anchor>ABObj_3_01vec_00_01LAVector_00_01double_01_4a4</anchor>
      <arglist>(const ABObj&lt; vec, LAVector, c &gt; &amp;obj)</arglist>
    </member>
    <member kind="function">
      <type>const LAVector &amp;</type>
      <name>obj</name>
      <anchor>ABObj_3_01vec_00_01LAVector_00_01double_01_4a5</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>f</name>
      <anchor>ABObj_3_01vec_00_01LAVector_00_01double_01_4a6</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="private">
      <type>ABObj &amp;</type>
      <name>operator=</name>
      <anchor>ABObj_3_01vec_00_01LAVector_00_01double_01_4d0</anchor>
      <arglist>(const ABObj &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>const LAVector &amp;</type>
      <name>theObject</name>
      <anchor>ABObj_3_01vec_00_01LAVector_00_01double_01_4r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theFactor</name>
      <anchor>ABObj_3_01vec_00_01LAVector_00_01double_01_4r1</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ABProd</name>
    <filename>classABProd.html</filename>
    <templarg>M1</templarg>
    <templarg>M2</templarg>
    <member kind="function">
      <type></type>
      <name>ABProd</name>
      <anchor>ABProda0</anchor>
      <arglist>(const M1 &amp;a, const M2 &amp;b)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~ABProd</name>
      <anchor>ABProda1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ABProd</name>
      <anchor>ABProda2</anchor>
      <arglist>(const ABProd &amp;prod)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ABProd</name>
      <anchor>ABProda3</anchor>
      <arglist>(const ABProd&lt; A, B &gt; &amp;prod)</arglist>
    </member>
    <member kind="function">
      <type>const M1 &amp;</type>
      <name>a</name>
      <anchor>ABProda4</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const M2 &amp;</type>
      <name>b</name>
      <anchor>ABProda5</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="private">
      <type></type>
      <name>ABProd</name>
      <anchor>ABProdd0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>ABProd &amp;</type>
      <name>operator=</name>
      <anchor>ABProdd1</anchor>
      <arglist>(const ABProd &amp;)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>ABProd &amp;</type>
      <name>operator=</name>
      <anchor>ABProdd2</anchor>
      <arglist>(const ABProd&lt; A, B &gt; &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>M1</type>
      <name>theA</name>
      <anchor>ABProdr0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>M2</type>
      <name>theB</name>
      <anchor>ABProdr1</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ABSum</name>
    <filename>classABSum.html</filename>
    <templarg>M1</templarg>
    <templarg>M2</templarg>
    <member kind="function">
      <type></type>
      <name>ABSum</name>
      <anchor>ABSuma0</anchor>
      <arglist>(const M1 &amp;a, const M2 &amp;b)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~ABSum</name>
      <anchor>ABSuma1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ABSum</name>
      <anchor>ABSuma2</anchor>
      <arglist>(const ABSum &amp;sum)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ABSum</name>
      <anchor>ABSuma3</anchor>
      <arglist>(const ABSum&lt; A, B &gt; &amp;sum)</arglist>
    </member>
    <member kind="function">
      <type>const M1 &amp;</type>
      <name>a</name>
      <anchor>ABSuma4</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const M2 &amp;</type>
      <name>b</name>
      <anchor>ABSuma5</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="private">
      <type></type>
      <name>ABSum</name>
      <anchor>ABSumd0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>ABSum &amp;</type>
      <name>operator=</name>
      <anchor>ABSumd1</anchor>
      <arglist>(const ABSum &amp;)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>ABSum &amp;</type>
      <name>operator=</name>
      <anchor>ABSumd2</anchor>
      <arglist>(const ABSum&lt; A, B &gt; &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>M1</type>
      <name>theA</name>
      <anchor>ABSumr0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>M2</type>
      <name>theB</name>
      <anchor>ABSumr1</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>AlgebraicProdType</name>
    <filename>classAlgebraicProdType.html</filename>
    <templarg>A</templarg>
    <templarg>B</templarg>
    <member kind="typedef" protection="private">
      <type>gen</type>
      <name>Type</name>
      <anchor>AlgebraicProdTypey0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>AlgebraicProdType&lt; gen, gen &gt;</name>
    <filename>classAlgebraicProdType_3_01gen_00_01gen_01_4.html</filename>
    <member kind="typedef">
      <type>gen</type>
      <name>Type</name>
      <anchor>AlgebraicProdType_3_01gen_00_01gen_01_4w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>AlgebraicProdType&lt; gen, sym &gt;</name>
    <filename>classAlgebraicProdType_3_01gen_00_01sym_01_4.html</filename>
    <member kind="typedef">
      <type>gen</type>
      <name>Type</name>
      <anchor>AlgebraicProdType_3_01gen_00_01sym_01_4w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>AlgebraicProdType&lt; gen, vec &gt;</name>
    <filename>classAlgebraicProdType_3_01gen_00_01vec_01_4.html</filename>
    <member kind="typedef">
      <type>vec</type>
      <name>Type</name>
      <anchor>AlgebraicProdType_3_01gen_00_01vec_01_4w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>AlgebraicProdType&lt; sym, gen &gt;</name>
    <filename>classAlgebraicProdType_3_01sym_00_01gen_01_4.html</filename>
    <member kind="typedef">
      <type>gen</type>
      <name>Type</name>
      <anchor>AlgebraicProdType_3_01sym_00_01gen_01_4w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>AlgebraicProdType&lt; sym, sym &gt;</name>
    <filename>classAlgebraicProdType_3_01sym_00_01sym_01_4.html</filename>
    <member kind="typedef">
      <type>gen</type>
      <name>Type</name>
      <anchor>AlgebraicProdType_3_01sym_00_01sym_01_4w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>AlgebraicProdType&lt; sym, vec &gt;</name>
    <filename>classAlgebraicProdType_3_01sym_00_01vec_01_4.html</filename>
    <member kind="typedef">
      <type>vec</type>
      <name>Type</name>
      <anchor>AlgebraicProdType_3_01sym_00_01vec_01_4w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>AlgebraicProdType&lt; T, T &gt;</name>
    <filename>classAlgebraicProdType_3_01T_00_01T_01_4.html</filename>
    <templarg>T</templarg>
    <member kind="typedef" protection="private">
      <type>T</type>
      <name>Type</name>
      <anchor>AlgebraicProdType_3_01T_00_01T_01_4y0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>AlgebraicProdType&lt; vec, gen &gt;</name>
    <filename>classAlgebraicProdType_3_01vec_00_01gen_01_4.html</filename>
    <member kind="typedef" protection="private">
      <type>gen</type>
      <name>Type</name>
      <anchor>AlgebraicProdType_3_01vec_00_01gen_01_4y0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>AlgebraicProdType&lt; vec, sym &gt;</name>
    <filename>classAlgebraicProdType_3_01vec_00_01sym_01_4.html</filename>
    <member kind="typedef" protection="private">
      <type>gen</type>
      <name>Type</name>
      <anchor>AlgebraicProdType_3_01vec_00_01sym_01_4y0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>AlgebraicSumType</name>
    <filename>classAlgebraicSumType.html</filename>
    <templarg>A</templarg>
    <templarg>B</templarg>
    <member kind="typedef">
      <type>gen</type>
      <name>Type</name>
      <anchor>AlgebraicSumTypew0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>AlgebraicSumType&lt; gen, vec &gt;</name>
    <filename>classAlgebraicSumType_3_01gen_00_01vec_01_4.html</filename>
    <member kind="typedef" protection="private">
      <type>gen</type>
      <name>Type</name>
      <anchor>AlgebraicSumType_3_01gen_00_01vec_01_4y0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>AlgebraicSumType&lt; sym, vec &gt;</name>
    <filename>classAlgebraicSumType_3_01sym_00_01vec_01_4.html</filename>
    <member kind="typedef" protection="private">
      <type>gen</type>
      <name>Type</name>
      <anchor>AlgebraicSumType_3_01sym_00_01vec_01_4y0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>AlgebraicSumType&lt; T, T &gt;</name>
    <filename>classAlgebraicSumType_3_01T_00_01T_01_4.html</filename>
    <templarg>T</templarg>
    <member kind="typedef">
      <type>T</type>
      <name>Type</name>
      <anchor>AlgebraicSumType_3_01T_00_01T_01_4w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>AlgebraicSumType&lt; vec, gen &gt;</name>
    <filename>classAlgebraicSumType_3_01vec_00_01gen_01_4.html</filename>
    <member kind="typedef" protection="private">
      <type>gen</type>
      <name>Type</name>
      <anchor>AlgebraicSumType_3_01vec_00_01gen_01_4y0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>AlgebraicSumType&lt; vec, sym &gt;</name>
    <filename>classAlgebraicSumType_3_01vec_00_01sym_01_4.html</filename>
    <member kind="typedef" protection="private">
      <type>gen</type>
      <name>Type</name>
      <anchor>AlgebraicSumType_3_01vec_00_01sym_01_4y0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>AnalyticalGradientCalculator</name>
    <filename>classAnalyticalGradientCalculator.html</filename>
    <base>GradientCalculator</base>
    <member kind="function">
      <type></type>
      <name>AnalyticalGradientCalculator</name>
      <anchor>AnalyticalGradientCalculatora0</anchor>
      <arglist>(const FCNGradientBase &amp;fcn, const MnUserTransformation &amp;state)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~AnalyticalGradientCalculator</name>
      <anchor>AnalyticalGradientCalculatora1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual FunctionGradient</type>
      <name>operator()</name>
      <anchor>AnalyticalGradientCalculatora2</anchor>
      <arglist>(const MinimumParameters &amp;) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual FunctionGradient</type>
      <name>operator()</name>
      <anchor>AnalyticalGradientCalculatora3</anchor>
      <arglist>(const MinimumParameters &amp;, const FunctionGradient &amp;) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>checkGradient</name>
      <anchor>AnalyticalGradientCalculatora4</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="variable" protection="private">
      <type>const FCNGradientBase &amp;</type>
      <name>theGradCalc</name>
      <anchor>AnalyticalGradientCalculatorr0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>const MnUserTransformation &amp;</type>
      <name>theTransformation</name>
      <anchor>AnalyticalGradientCalculatorr1</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>BasicFunctionGradient</name>
    <filename>classBasicFunctionGradient.html</filename>
    <member kind="function">
      <type></type>
      <name>BasicFunctionGradient</name>
      <anchor>BasicFunctionGradienta0</anchor>
      <arglist>(unsigned int n)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>BasicFunctionGradient</name>
      <anchor>BasicFunctionGradienta1</anchor>
      <arglist>(const MnAlgebraicVector &amp;grd)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>BasicFunctionGradient</name>
      <anchor>BasicFunctionGradienta2</anchor>
      <arglist>(const MnAlgebraicVector &amp;grd, const MnAlgebraicVector &amp;g2, const MnAlgebraicVector &amp;gstep)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~BasicFunctionGradient</name>
      <anchor>BasicFunctionGradienta3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>BasicFunctionGradient</name>
      <anchor>BasicFunctionGradienta4</anchor>
      <arglist>(const BasicFunctionGradient &amp;grad)</arglist>
    </member>
    <member kind="function">
      <type>BasicFunctionGradient &amp;</type>
      <name>operator=</name>
      <anchor>BasicFunctionGradienta5</anchor>
      <arglist>(const BasicFunctionGradient &amp;grad)</arglist>
    </member>
    <member kind="function">
      <type>void *</type>
      <name>operator new</name>
      <anchor>BasicFunctionGradienta6</anchor>
      <arglist>(size_t nbytes)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>operator delete</name>
      <anchor>BasicFunctionGradienta7</anchor>
      <arglist>(void *p, size_t)</arglist>
    </member>
    <member kind="function">
      <type>const MnAlgebraicVector &amp;</type>
      <name>grad</name>
      <anchor>BasicFunctionGradienta8</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const MnAlgebraicVector &amp;</type>
      <name>vec</name>
      <anchor>BasicFunctionGradienta9</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>isValid</name>
      <anchor>BasicFunctionGradienta10</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>isAnalytical</name>
      <anchor>BasicFunctionGradienta11</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const MnAlgebraicVector &amp;</type>
      <name>g2</name>
      <anchor>BasicFunctionGradienta12</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const MnAlgebraicVector &amp;</type>
      <name>gstep</name>
      <anchor>BasicFunctionGradienta13</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="variable" protection="private">
      <type>MnAlgebraicVector</type>
      <name>theGradient</name>
      <anchor>BasicFunctionGradientr0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>MnAlgebraicVector</type>
      <name>theG2ndDerivative</name>
      <anchor>BasicFunctionGradientr1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>MnAlgebraicVector</type>
      <name>theGStepSize</name>
      <anchor>BasicFunctionGradientr2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool</type>
      <name>theValid</name>
      <anchor>BasicFunctionGradientr3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool</type>
      <name>theAnalytical</name>
      <anchor>BasicFunctionGradientr4</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>BasicFunctionMinimum</name>
    <filename>classBasicFunctionMinimum.html</filename>
    <member kind="function">
      <type></type>
      <name>BasicFunctionMinimum</name>
      <anchor>BasicFunctionMinimuma0</anchor>
      <arglist>(const MinimumSeed &amp;seed, double up)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>BasicFunctionMinimum</name>
      <anchor>BasicFunctionMinimuma1</anchor>
      <arglist>(const MinimumSeed &amp;seed, const std::vector&lt; MinimumState &gt; &amp;states, double up)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>BasicFunctionMinimum</name>
      <anchor>BasicFunctionMinimuma2</anchor>
      <arglist>(const MinimumSeed &amp;seed, const std::vector&lt; MinimumState &gt; &amp;states, double up, MnReachedCallLimit)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>BasicFunctionMinimum</name>
      <anchor>BasicFunctionMinimuma3</anchor>
      <arglist>(const MinimumSeed &amp;seed, const std::vector&lt; MinimumState &gt; &amp;states, double up, MnAboveMaxEdm)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>BasicFunctionMinimum</name>
      <anchor>BasicFunctionMinimuma4</anchor>
      <arglist>(const BasicFunctionMinimum &amp;min)</arglist>
    </member>
    <member kind="function">
      <type>BasicFunctionMinimum &amp;</type>
      <name>operator=</name>
      <anchor>BasicFunctionMinimuma5</anchor>
      <arglist>(const BasicFunctionMinimum &amp;min)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~BasicFunctionMinimum</name>
      <anchor>BasicFunctionMinimuma6</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>add</name>
      <anchor>BasicFunctionMinimuma7</anchor>
      <arglist>(const MinimumState &amp;state)</arglist>
    </member>
    <member kind="function">
      <type>const MinimumSeed &amp;</type>
      <name>seed</name>
      <anchor>BasicFunctionMinimuma8</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const std::vector&lt; MinimumState &gt; &amp;</type>
      <name>states</name>
      <anchor>BasicFunctionMinimuma9</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const MnUserParameterState &amp;</type>
      <name>userState</name>
      <anchor>BasicFunctionMinimuma10</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const MnUserParameters &amp;</type>
      <name>userParameters</name>
      <anchor>BasicFunctionMinimuma11</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const MnUserCovariance &amp;</type>
      <name>userCovariance</name>
      <anchor>BasicFunctionMinimuma12</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void *</type>
      <name>operator new</name>
      <anchor>BasicFunctionMinimuma13</anchor>
      <arglist>(size_t nbytes)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>operator delete</name>
      <anchor>BasicFunctionMinimuma14</anchor>
      <arglist>(void *p, size_t)</arglist>
    </member>
    <member kind="function">
      <type>const MinimumState &amp;</type>
      <name>state</name>
      <anchor>BasicFunctionMinimuma15</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const MinimumParameters &amp;</type>
      <name>parameters</name>
      <anchor>BasicFunctionMinimuma16</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const MinimumError &amp;</type>
      <name>error</name>
      <anchor>BasicFunctionMinimuma17</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const FunctionGradient &amp;</type>
      <name>grad</name>
      <anchor>BasicFunctionMinimuma18</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>fval</name>
      <anchor>BasicFunctionMinimuma19</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>edm</name>
      <anchor>BasicFunctionMinimuma20</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>nfcn</name>
      <anchor>BasicFunctionMinimuma21</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>up</name>
      <anchor>BasicFunctionMinimuma22</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>isValid</name>
      <anchor>BasicFunctionMinimuma23</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>hasValidParameters</name>
      <anchor>BasicFunctionMinimuma24</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>hasValidCovariance</name>
      <anchor>BasicFunctionMinimuma25</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>hasAccurateCovar</name>
      <anchor>BasicFunctionMinimuma26</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>hasPosDefCovar</name>
      <anchor>BasicFunctionMinimuma27</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>hasMadePosDefCovar</name>
      <anchor>BasicFunctionMinimuma28</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>hesseFailed</name>
      <anchor>BasicFunctionMinimuma29</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>hasCovariance</name>
      <anchor>BasicFunctionMinimuma30</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>isAboveMaxEdm</name>
      <anchor>BasicFunctionMinimuma31</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>hasReachedCallLimit</name>
      <anchor>BasicFunctionMinimuma32</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="variable" protection="private">
      <type>MinimumSeed</type>
      <name>theSeed</name>
      <anchor>BasicFunctionMinimumr0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>std::vector&lt; MinimumState &gt;</type>
      <name>theStates</name>
      <anchor>BasicFunctionMinimumr1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theErrorDef</name>
      <anchor>BasicFunctionMinimumr2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool</type>
      <name>theAboveMaxEdm</name>
      <anchor>BasicFunctionMinimumr3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool</type>
      <name>theReachedCallLimit</name>
      <anchor>BasicFunctionMinimumr4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>MnUserParameterState</type>
      <name>theUserState</name>
      <anchor>BasicFunctionMinimumr5</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>BasicFunctionMinimum::MnAboveMaxEdm</name>
    <filename>classBasicFunctionMinimum_1_1MnAboveMaxEdm.html</filename>
  </compound>
  <compound kind="class">
    <name>BasicFunctionMinimum::MnReachedCallLimit</name>
    <filename>classBasicFunctionMinimum_1_1MnReachedCallLimit.html</filename>
  </compound>
  <compound kind="class">
    <name>BasicMinimumError</name>
    <filename>classBasicMinimumError.html</filename>
    <member kind="function">
      <type></type>
      <name>BasicMinimumError</name>
      <anchor>BasicMinimumErrora0</anchor>
      <arglist>(unsigned int n)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>BasicMinimumError</name>
      <anchor>BasicMinimumErrora1</anchor>
      <arglist>(const MnAlgebraicSymMatrix &amp;mat, double dcov)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>BasicMinimumError</name>
      <anchor>BasicMinimumErrora2</anchor>
      <arglist>(const MnAlgebraicSymMatrix &amp;mat, MnHesseFailed)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>BasicMinimumError</name>
      <anchor>BasicMinimumErrora3</anchor>
      <arglist>(const MnAlgebraicSymMatrix &amp;mat, MnMadePosDef)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>BasicMinimumError</name>
      <anchor>BasicMinimumErrora4</anchor>
      <arglist>(const MnAlgebraicSymMatrix &amp;mat, MnInvertFailed)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>BasicMinimumError</name>
      <anchor>BasicMinimumErrora5</anchor>
      <arglist>(const MnAlgebraicSymMatrix &amp;mat, MnNotPosDef)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~BasicMinimumError</name>
      <anchor>BasicMinimumErrora6</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>BasicMinimumError</name>
      <anchor>BasicMinimumErrora7</anchor>
      <arglist>(const BasicMinimumError &amp;e)</arglist>
    </member>
    <member kind="function">
      <type>BasicMinimumError &amp;</type>
      <name>operator=</name>
      <anchor>BasicMinimumErrora8</anchor>
      <arglist>(const BasicMinimumError &amp;err)</arglist>
    </member>
    <member kind="function">
      <type>void *</type>
      <name>operator new</name>
      <anchor>BasicMinimumErrora9</anchor>
      <arglist>(size_t nbytes)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>operator delete</name>
      <anchor>BasicMinimumErrora10</anchor>
      <arglist>(void *p, size_t)</arglist>
    </member>
    <member kind="function">
      <type>MnAlgebraicSymMatrix</type>
      <name>matrix</name>
      <anchor>BasicMinimumErrora11</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const MnAlgebraicSymMatrix &amp;</type>
      <name>invHessian</name>
      <anchor>BasicMinimumErrora12</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>MnAlgebraicSymMatrix</type>
      <name>hessian</name>
      <anchor>BasicMinimumErrora13</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>dcovar</name>
      <anchor>BasicMinimumErrora14</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>isAccurate</name>
      <anchor>BasicMinimumErrora15</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>isValid</name>
      <anchor>BasicMinimumErrora16</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>isPosDef</name>
      <anchor>BasicMinimumErrora17</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>isMadePosDef</name>
      <anchor>BasicMinimumErrora18</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>hesseFailed</name>
      <anchor>BasicMinimumErrora19</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>invertFailed</name>
      <anchor>BasicMinimumErrora20</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>isAvailable</name>
      <anchor>BasicMinimumErrora21</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="variable" protection="private">
      <type>MnAlgebraicSymMatrix</type>
      <name>theMatrix</name>
      <anchor>BasicMinimumErrorr0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theDCovar</name>
      <anchor>BasicMinimumErrorr1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool</type>
      <name>theValid</name>
      <anchor>BasicMinimumErrorr2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool</type>
      <name>thePosDef</name>
      <anchor>BasicMinimumErrorr3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool</type>
      <name>theMadePosDef</name>
      <anchor>BasicMinimumErrorr4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool</type>
      <name>theHesseFailed</name>
      <anchor>BasicMinimumErrorr5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool</type>
      <name>theInvertFailed</name>
      <anchor>BasicMinimumErrorr6</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool</type>
      <name>theAvailable</name>
      <anchor>BasicMinimumErrorr7</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>BasicMinimumError::MnHesseFailed</name>
    <filename>classBasicMinimumError_1_1MnHesseFailed.html</filename>
  </compound>
  <compound kind="class">
    <name>BasicMinimumError::MnInvertFailed</name>
    <filename>classBasicMinimumError_1_1MnInvertFailed.html</filename>
  </compound>
  <compound kind="class">
    <name>BasicMinimumError::MnMadePosDef</name>
    <filename>classBasicMinimumError_1_1MnMadePosDef.html</filename>
  </compound>
  <compound kind="class">
    <name>BasicMinimumError::MnNotPosDef</name>
    <filename>classBasicMinimumError_1_1MnNotPosDef.html</filename>
  </compound>
  <compound kind="class">
    <name>BasicMinimumParameters</name>
    <filename>classBasicMinimumParameters.html</filename>
    <member kind="function">
      <type></type>
      <name>BasicMinimumParameters</name>
      <anchor>BasicMinimumParametersa0</anchor>
      <arglist>(unsigned int n)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>BasicMinimumParameters</name>
      <anchor>BasicMinimumParametersa1</anchor>
      <arglist>(const MnAlgebraicVector &amp;avec, double fval)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>BasicMinimumParameters</name>
      <anchor>BasicMinimumParametersa2</anchor>
      <arglist>(const MnAlgebraicVector &amp;avec, const MnAlgebraicVector &amp;dirin, double fval)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~BasicMinimumParameters</name>
      <anchor>BasicMinimumParametersa3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>BasicMinimumParameters</name>
      <anchor>BasicMinimumParametersa4</anchor>
      <arglist>(const BasicMinimumParameters &amp;par)</arglist>
    </member>
    <member kind="function">
      <type>BasicMinimumParameters &amp;</type>
      <name>operator=</name>
      <anchor>BasicMinimumParametersa5</anchor>
      <arglist>(const BasicMinimumParameters &amp;par)</arglist>
    </member>
    <member kind="function">
      <type>void *</type>
      <name>operator new</name>
      <anchor>BasicMinimumParametersa6</anchor>
      <arglist>(size_t nbytes)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>operator delete</name>
      <anchor>BasicMinimumParametersa7</anchor>
      <arglist>(void *p, size_t)</arglist>
    </member>
    <member kind="function">
      <type>const MnAlgebraicVector &amp;</type>
      <name>vec</name>
      <anchor>BasicMinimumParametersa8</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const MnAlgebraicVector &amp;</type>
      <name>dirin</name>
      <anchor>BasicMinimumParametersa9</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>fval</name>
      <anchor>BasicMinimumParametersa10</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>isValid</name>
      <anchor>BasicMinimumParametersa11</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>hasStepSize</name>
      <anchor>BasicMinimumParametersa12</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="variable" protection="private">
      <type>MnAlgebraicVector</type>
      <name>theParameters</name>
      <anchor>BasicMinimumParametersr0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>MnAlgebraicVector</type>
      <name>theStepSize</name>
      <anchor>BasicMinimumParametersr1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theFVal</name>
      <anchor>BasicMinimumParametersr2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool</type>
      <name>theValid</name>
      <anchor>BasicMinimumParametersr3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool</type>
      <name>theHasStep</name>
      <anchor>BasicMinimumParametersr4</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>BasicMinimumSeed</name>
    <filename>classBasicMinimumSeed.html</filename>
    <member kind="function">
      <type></type>
      <name>BasicMinimumSeed</name>
      <anchor>BasicMinimumSeeda0</anchor>
      <arglist>(const MinimumState &amp;state, const MnUserTransformation &amp;trafo)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~BasicMinimumSeed</name>
      <anchor>BasicMinimumSeeda1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>BasicMinimumSeed</name>
      <anchor>BasicMinimumSeeda2</anchor>
      <arglist>(const BasicMinimumSeed &amp;seed)</arglist>
    </member>
    <member kind="function">
      <type>BasicMinimumSeed &amp;</type>
      <name>operator=</name>
      <anchor>BasicMinimumSeeda3</anchor>
      <arglist>(const BasicMinimumSeed &amp;seed)</arglist>
    </member>
    <member kind="function">
      <type>void *</type>
      <name>operator new</name>
      <anchor>BasicMinimumSeeda4</anchor>
      <arglist>(size_t nbytes)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>operator delete</name>
      <anchor>BasicMinimumSeeda5</anchor>
      <arglist>(void *p, size_t)</arglist>
    </member>
    <member kind="function">
      <type>const MinimumState &amp;</type>
      <name>state</name>
      <anchor>BasicMinimumSeeda6</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const MinimumParameters &amp;</type>
      <name>parameters</name>
      <anchor>BasicMinimumSeeda7</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const MinimumError &amp;</type>
      <name>error</name>
      <anchor>BasicMinimumSeeda8</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const FunctionGradient &amp;</type>
      <name>gradient</name>
      <anchor>BasicMinimumSeeda9</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const MnUserTransformation &amp;</type>
      <name>trafo</name>
      <anchor>BasicMinimumSeeda10</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const MnMachinePrecision &amp;</type>
      <name>precision</name>
      <anchor>BasicMinimumSeeda11</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>fval</name>
      <anchor>BasicMinimumSeeda12</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>edm</name>
      <anchor>BasicMinimumSeeda13</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>unsigned int</type>
      <name>nfcn</name>
      <anchor>BasicMinimumSeeda14</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>isValid</name>
      <anchor>BasicMinimumSeeda15</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="variable" protection="private">
      <type>MinimumState</type>
      <name>theState</name>
      <anchor>BasicMinimumSeedr0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>MnUserTransformation</type>
      <name>theTrafo</name>
      <anchor>BasicMinimumSeedr1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool</type>
      <name>theValid</name>
      <anchor>BasicMinimumSeedr2</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>BasicMinimumState</name>
    <filename>classBasicMinimumState.html</filename>
    <member kind="function">
      <type></type>
      <name>BasicMinimumState</name>
      <anchor>BasicMinimumStatea0</anchor>
      <arglist>(unsigned int n)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>BasicMinimumState</name>
      <anchor>BasicMinimumStatea1</anchor>
      <arglist>(const MinimumParameters &amp;states, const MinimumError &amp;err, const FunctionGradient &amp;grad, double edm, int nfcn)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>BasicMinimumState</name>
      <anchor>BasicMinimumStatea2</anchor>
      <arglist>(const MinimumParameters &amp;states, double edm, int nfcn)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~BasicMinimumState</name>
      <anchor>BasicMinimumStatea3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>BasicMinimumState</name>
      <anchor>BasicMinimumStatea4</anchor>
      <arglist>(const BasicMinimumState &amp;state)</arglist>
    </member>
    <member kind="function">
      <type>BasicMinimumState &amp;</type>
      <name>operator=</name>
      <anchor>BasicMinimumStatea5</anchor>
      <arglist>(const BasicMinimumState &amp;state)</arglist>
    </member>
    <member kind="function">
      <type>void *</type>
      <name>operator new</name>
      <anchor>BasicMinimumStatea6</anchor>
      <arglist>(size_t nbytes)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>operator delete</name>
      <anchor>BasicMinimumStatea7</anchor>
      <arglist>(void *p, size_t)</arglist>
    </member>
    <member kind="function">
      <type>const MinimumParameters &amp;</type>
      <name>parameters</name>
      <anchor>BasicMinimumStatea8</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const MnAlgebraicVector &amp;</type>
      <name>vec</name>
      <anchor>BasicMinimumStatea9</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>size</name>
      <anchor>BasicMinimumStatea10</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const MinimumError &amp;</type>
      <name>error</name>
      <anchor>BasicMinimumStatea11</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const FunctionGradient &amp;</type>
      <name>gradient</name>
      <anchor>BasicMinimumStatea12</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>fval</name>
      <anchor>BasicMinimumStatea13</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>edm</name>
      <anchor>BasicMinimumStatea14</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>nfcn</name>
      <anchor>BasicMinimumStatea15</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>isValid</name>
      <anchor>BasicMinimumStatea16</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>hasParameters</name>
      <anchor>BasicMinimumStatea17</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>hasCovariance</name>
      <anchor>BasicMinimumStatea18</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="variable" protection="private">
      <type>MinimumParameters</type>
      <name>theParameters</name>
      <anchor>BasicMinimumStater0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>MinimumError</type>
      <name>theError</name>
      <anchor>BasicMinimumStater1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>FunctionGradient</type>
      <name>theGradient</name>
      <anchor>BasicMinimumStater2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theEDM</name>
      <anchor>BasicMinimumStater3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>theNFcn</name>
      <anchor>BasicMinimumStater4</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>CombinedMinimizer</name>
    <filename>classCombinedMinimizer.html</filename>
    <base>ModularFunctionMinimizer</base>
    <member kind="function">
      <type></type>
      <name>CombinedMinimizer</name>
      <anchor>CombinedMinimizera0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~CombinedMinimizer</name>
      <anchor>CombinedMinimizera1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>const MinimumSeedGenerator &amp;</type>
      <name>seedGenerator</name>
      <anchor>CombinedMinimizera2</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const MinimumBuilder &amp;</type>
      <name>builder</name>
      <anchor>CombinedMinimizera3</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual FunctionMinimum</type>
      <name>minimize</name>
      <anchor>VariableMetricMinimizera4</anchor>
      <arglist>(const FCNBase &amp;, const std::vector&lt; double &gt; &amp;, const std::vector&lt; double &gt; &amp;, unsigned int stra=1, unsigned int maxfcn=0, double toler=0.1) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual FunctionMinimum</type>
      <name>minimize</name>
      <anchor>VariableMetricMinimizera5</anchor>
      <arglist>(const FCNGradientBase &amp;, const std::vector&lt; double &gt; &amp;, const std::vector&lt; double &gt; &amp;, unsigned int stra=1, unsigned int maxfcn=0, double toler=0.1) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual FunctionMinimum</type>
      <name>minimize</name>
      <anchor>VariableMetricMinimizera6</anchor>
      <arglist>(const FCNBase &amp;, const std::vector&lt; double &gt; &amp;, const std::vector&lt; double &gt; &amp;, unsigned int, unsigned int stra=1, unsigned int maxfcn=0, double toler=0.1) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual FunctionMinimum</type>
      <name>minimize</name>
      <anchor>VariableMetricMinimizera7</anchor>
      <arglist>(const FCNGradientBase &amp;, const std::vector&lt; double &gt; &amp;, const std::vector&lt; double &gt; &amp;, unsigned int, unsigned int stra=1, unsigned int maxfcn=0, double toler=0.1) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual FunctionMinimum</type>
      <name>minimize</name>
      <anchor>VariableMetricMinimizera8</anchor>
      <arglist>(const FCNBase &amp;, const MnUserParameters &amp;, const MnStrategy &amp;, unsigned int maxfcn=0, double toler=0.1) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual FunctionMinimum</type>
      <name>minimize</name>
      <anchor>VariableMetricMinimizera9</anchor>
      <arglist>(const FCNBase &amp;, const MnUserParameters &amp;, const MnUserCovariance &amp;, const MnStrategy &amp;, unsigned int maxfcn=0, double toler=0.1) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual FunctionMinimum</type>
      <name>minimize</name>
      <anchor>VariableMetricMinimizera10</anchor>
      <arglist>(const FCNBase &amp;, const MnUserParameterState &amp;, const MnStrategy &amp;, unsigned int maxfcn=0, double toler=0.1) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual FunctionMinimum</type>
      <name>minimize</name>
      <anchor>VariableMetricMinimizera11</anchor>
      <arglist>(const MnFcn &amp;, const GradientCalculator &amp;, const MinimumSeed &amp;, const MnStrategy &amp;, unsigned int, double) const </arglist>
    </member>
    <member kind="variable" protection="private">
      <type>MnSeedGenerator</type>
      <name>theMinSeedGen</name>
      <anchor>CombinedMinimizerr0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>CombinedMinimumBuilder</type>
      <name>theMinBuilder</name>
      <anchor>CombinedMinimizerr1</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>CombinedMinimumBuilder</name>
    <filename>classCombinedMinimumBuilder.html</filename>
    <base>MinimumBuilder</base>
    <member kind="function">
      <type></type>
      <name>CombinedMinimumBuilder</name>
      <anchor>CombinedMinimumBuildera0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~CombinedMinimumBuilder</name>
      <anchor>CombinedMinimumBuildera1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual FunctionMinimum</type>
      <name>minimum</name>
      <anchor>CombinedMinimumBuildera2</anchor>
      <arglist>(const MnFcn &amp;, const GradientCalculator &amp;, const MinimumSeed &amp;, const MnStrategy &amp;, unsigned int, double) const </arglist>
    </member>
    <member kind="variable" protection="private">
      <type>VariableMetricMinimizer</type>
      <name>theVMMinimizer</name>
      <anchor>CombinedMinimumBuilderr0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>SimplexMinimizer</type>
      <name>theSimplexMinimizer</name>
      <anchor>CombinedMinimumBuilderr1</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ContoursError</name>
    <filename>classContoursError.html</filename>
    <member kind="function">
      <type></type>
      <name>ContoursError</name>
      <anchor>ContoursErrora0</anchor>
      <arglist>(unsigned int parx, unsigned int pary, const std::vector&lt; std::pair&lt; double, double &gt; &gt; &amp;points, const MinosError &amp;xmnos, const MinosError &amp;ymnos, unsigned int nfcn)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~ContoursError</name>
      <anchor>ContoursErrora1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ContoursError</name>
      <anchor>ContoursErrora2</anchor>
      <arglist>(const ContoursError &amp;cont)</arglist>
    </member>
    <member kind="function">
      <type>ContoursError &amp;</type>
      <name>operator()</name>
      <anchor>ContoursErrora3</anchor>
      <arglist>(const ContoursError &amp;cont)</arglist>
    </member>
    <member kind="function">
      <type>const std::vector&lt; std::pair&lt; double, double &gt; &gt; &amp;</type>
      <name>operator()</name>
      <anchor>ContoursErrora4</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>std::pair&lt; double, double &gt;</type>
      <name>xMinos</name>
      <anchor>ContoursErrora5</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>std::pair&lt; double, double &gt;</type>
      <name>yMinos</name>
      <anchor>ContoursErrora6</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>unsigned int</type>
      <name>xpar</name>
      <anchor>ContoursErrora7</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>unsigned int</type>
      <name>ypar</name>
      <anchor>ContoursErrora8</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const MinosError &amp;</type>
      <name>xMinosError</name>
      <anchor>ContoursErrora9</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const MinosError &amp;</type>
      <name>yMinosError</name>
      <anchor>ContoursErrora10</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>unsigned int</type>
      <name>nfcn</name>
      <anchor>ContoursErrora11</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>xmin</name>
      <anchor>ContoursErrora12</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>ymin</name>
      <anchor>ContoursErrora13</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="variable" protection="private">
      <type>unsigned int</type>
      <name>theParX</name>
      <anchor>ContoursErrorr0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>unsigned int</type>
      <name>theParY</name>
      <anchor>ContoursErrorr1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>std::vector&lt; std::pair&lt; double, double &gt; &gt;</type>
      <name>thePoints</name>
      <anchor>ContoursErrorr2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>MinosError</type>
      <name>theXMinos</name>
      <anchor>ContoursErrorr3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>MinosError</type>
      <name>theYMinos</name>
      <anchor>ContoursErrorr4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>unsigned int</type>
      <name>theNFcn</name>
      <anchor>ContoursErrorr5</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>DavidonErrorUpdator</name>
    <filename>classDavidonErrorUpdator.html</filename>
    <base>MinimumErrorUpdator</base>
    <member kind="function">
      <type></type>
      <name>DavidonErrorUpdator</name>
      <anchor>DavidonErrorUpdatora0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~DavidonErrorUpdator</name>
      <anchor>DavidonErrorUpdatora1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual MinimumError</type>
      <name>update</name>
      <anchor>DavidonErrorUpdatora2</anchor>
      <arglist>(const MinimumState &amp;, const MinimumParameters &amp;, const FunctionGradient &amp;) const </arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>FCNBase</name>
    <filename>classFCNBase.html</filename>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~FCNBase</name>
      <anchor>FCNBasea0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual double</type>
      <name>operator()</name>
      <anchor>FCNGradientBasea3</anchor>
      <arglist>(const std::vector&lt; double &gt; &amp;) const =0</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual double</type>
      <name>errorDef</name>
      <anchor>FCNGradientBasea4</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual double</type>
      <name>up</name>
      <anchor>FCNGradientBasea5</anchor>
      <arglist>() const =0</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>FCNGradientBase</name>
    <filename>classFCNGradientBase.html</filename>
    <base>FCNBase</base>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~FCNGradientBase</name>
      <anchor>FCNGradientBasea0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual std::vector&lt; double &gt;</type>
      <name>gradient</name>
      <anchor>FCNGradientBasea1</anchor>
      <arglist>(const std::vector&lt; double &gt; &amp;) const =0</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>checkGradient</name>
      <anchor>FCNGradientBasea2</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual double</type>
      <name>operator()</name>
      <anchor>FCNGradientBasea3</anchor>
      <arglist>(const std::vector&lt; double &gt; &amp;) const =0</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual double</type>
      <name>errorDef</name>
      <anchor>FCNGradientBasea4</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual double</type>
      <name>up</name>
      <anchor>FCNGradientBasea5</anchor>
      <arglist>() const =0</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>FunctionGradient</name>
    <filename>classFunctionGradient.html</filename>
    <member kind="function">
      <type></type>
      <name>FunctionGradient</name>
      <anchor>FunctionGradienta0</anchor>
      <arglist>(unsigned int n)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>FunctionGradient</name>
      <anchor>FunctionGradienta1</anchor>
      <arglist>(const MnAlgebraicVector &amp;grd)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>FunctionGradient</name>
      <anchor>FunctionGradienta2</anchor>
      <arglist>(const MnAlgebraicVector &amp;grd, const MnAlgebraicVector &amp;g2, const MnAlgebraicVector &amp;gstep)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~FunctionGradient</name>
      <anchor>FunctionGradienta3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>FunctionGradient</name>
      <anchor>FunctionGradienta4</anchor>
      <arglist>(const FunctionGradient &amp;grad)</arglist>
    </member>
    <member kind="function">
      <type>FunctionGradient &amp;</type>
      <name>operator=</name>
      <anchor>FunctionGradienta5</anchor>
      <arglist>(const FunctionGradient &amp;grad)</arglist>
    </member>
    <member kind="function">
      <type>const MnAlgebraicVector &amp;</type>
      <name>grad</name>
      <anchor>FunctionGradienta6</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const MnAlgebraicVector &amp;</type>
      <name>vec</name>
      <anchor>FunctionGradienta7</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>isValid</name>
      <anchor>FunctionGradienta8</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>isAnalytical</name>
      <anchor>FunctionGradienta9</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const MnAlgebraicVector &amp;</type>
      <name>g2</name>
      <anchor>FunctionGradienta10</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const MnAlgebraicVector &amp;</type>
      <name>gstep</name>
      <anchor>FunctionGradienta11</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="variable" protection="private">
      <type>MnRefCountedPointer&lt; BasicFunctionGradient &gt;</type>
      <name>theData</name>
      <anchor>FunctionGradientr0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>FunctionMinimizer</name>
    <filename>classFunctionMinimizer.html</filename>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~FunctionMinimizer</name>
      <anchor>FunctionMinimizera0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual FunctionMinimum</type>
      <name>minimize</name>
      <anchor>FunctionMinimizera1</anchor>
      <arglist>(const FCNBase &amp;, const std::vector&lt; double &gt; &amp;par, const std::vector&lt; double &gt; &amp;err, unsigned int strategy, unsigned int maxfcn, double toler) const =0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual FunctionMinimum</type>
      <name>minimize</name>
      <anchor>FunctionMinimizera2</anchor>
      <arglist>(const FCNGradientBase &amp;, const std::vector&lt; double &gt; &amp;par, const std::vector&lt; double &gt; &amp;err, unsigned int strategy, unsigned int maxfcn, double toler) const =0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual FunctionMinimum</type>
      <name>minimize</name>
      <anchor>FunctionMinimizera3</anchor>
      <arglist>(const FCNBase &amp;, const std::vector&lt; double &gt; &amp;par, const std::vector&lt; double &gt; &amp;cov, unsigned int nrow, unsigned int strategy, unsigned int maxfcn, double toler) const =0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual FunctionMinimum</type>
      <name>minimize</name>
      <anchor>FunctionMinimizera4</anchor>
      <arglist>(const FCNGradientBase &amp;, const std::vector&lt; double &gt; &amp;par, const std::vector&lt; double &gt; &amp;cov, unsigned int nrow, unsigned int strategy, unsigned int maxfcn, double toler) const =0</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>FunctionMinimum</name>
    <filename>classFunctionMinimum.html</filename>
    <member kind="function">
      <type></type>
      <name>FunctionMinimum</name>
      <anchor>FunctionMinimuma0</anchor>
      <arglist>(const MinimumSeed &amp;seed, double up)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>FunctionMinimum</name>
      <anchor>FunctionMinimuma1</anchor>
      <arglist>(const MinimumSeed &amp;seed, const std::vector&lt; MinimumState &gt; &amp;states, double up)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>FunctionMinimum</name>
      <anchor>FunctionMinimuma2</anchor>
      <arglist>(const MinimumSeed &amp;seed, const std::vector&lt; MinimumState &gt; &amp;states, double up, MnReachedCallLimit)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>FunctionMinimum</name>
      <anchor>FunctionMinimuma3</anchor>
      <arglist>(const MinimumSeed &amp;seed, const std::vector&lt; MinimumState &gt; &amp;states, double up, MnAboveMaxEdm)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>FunctionMinimum</name>
      <anchor>FunctionMinimuma4</anchor>
      <arglist>(const FunctionMinimum &amp;min)</arglist>
    </member>
    <member kind="function">
      <type>FunctionMinimum &amp;</type>
      <name>operator=</name>
      <anchor>FunctionMinimuma5</anchor>
      <arglist>(const FunctionMinimum &amp;min)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~FunctionMinimum</name>
      <anchor>FunctionMinimuma6</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>add</name>
      <anchor>FunctionMinimuma7</anchor>
      <arglist>(const MinimumState &amp;state)</arglist>
    </member>
    <member kind="function">
      <type>const MinimumSeed &amp;</type>
      <name>seed</name>
      <anchor>FunctionMinimuma8</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const std::vector&lt; MinimumState &gt; &amp;</type>
      <name>states</name>
      <anchor>FunctionMinimuma9</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const MnUserParameterState &amp;</type>
      <name>userState</name>
      <anchor>FunctionMinimuma10</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const MnUserParameters &amp;</type>
      <name>userParameters</name>
      <anchor>FunctionMinimuma11</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const MnUserCovariance &amp;</type>
      <name>userCovariance</name>
      <anchor>FunctionMinimuma12</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const MinimumState &amp;</type>
      <name>state</name>
      <anchor>FunctionMinimuma13</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const MinimumParameters &amp;</type>
      <name>parameters</name>
      <anchor>FunctionMinimuma14</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const MinimumError &amp;</type>
      <name>error</name>
      <anchor>FunctionMinimuma15</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const FunctionGradient &amp;</type>
      <name>grad</name>
      <anchor>FunctionMinimuma16</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>fval</name>
      <anchor>FunctionMinimuma17</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>edm</name>
      <anchor>FunctionMinimuma18</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>nfcn</name>
      <anchor>FunctionMinimuma19</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>up</name>
      <anchor>FunctionMinimuma20</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>isValid</name>
      <anchor>FunctionMinimuma21</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>hasValidParameters</name>
      <anchor>FunctionMinimuma22</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>hasValidCovariance</name>
      <anchor>FunctionMinimuma23</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>hasAccurateCovar</name>
      <anchor>FunctionMinimuma24</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>hasPosDefCovar</name>
      <anchor>FunctionMinimuma25</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>hasMadePosDefCovar</name>
      <anchor>FunctionMinimuma26</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>hesseFailed</name>
      <anchor>FunctionMinimuma27</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>hasCovariance</name>
      <anchor>FunctionMinimuma28</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>isAboveMaxEdm</name>
      <anchor>FunctionMinimuma29</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>hasReachedCallLimit</name>
      <anchor>FunctionMinimuma30</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="variable" protection="private">
      <type>MnRefCountedPointer&lt; BasicFunctionMinimum &gt;</type>
      <name>theData</name>
      <anchor>FunctionMinimumr0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>FunctionMinimum::MnAboveMaxEdm</name>
    <filename>classFunctionMinimum_1_1MnAboveMaxEdm.html</filename>
  </compound>
  <compound kind="class">
    <name>FunctionMinimum::MnReachedCallLimit</name>
    <filename>classFunctionMinimum_1_1MnReachedCallLimit.html</filename>
  </compound>
  <compound kind="class">
    <name>gen</name>
    <filename>classgen.html</filename>
  </compound>
  <compound kind="class">
    <name>GradientCalculator</name>
    <filename>classGradientCalculator.html</filename>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~GradientCalculator</name>
      <anchor>GradientCalculatora0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual FunctionGradient</type>
      <name>operator()</name>
      <anchor>GradientCalculatora1</anchor>
      <arglist>(const MinimumParameters &amp;) const =0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual FunctionGradient</type>
      <name>operator()</name>
      <anchor>GradientCalculatora2</anchor>
      <arglist>(const MinimumParameters &amp;, const FunctionGradient &amp;) const =0</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>HessianGradientCalculator</name>
    <filename>classHessianGradientCalculator.html</filename>
    <base>GradientCalculator</base>
    <member kind="function">
      <type></type>
      <name>HessianGradientCalculator</name>
      <anchor>HessianGradientCalculatora0</anchor>
      <arglist>(const MnFcn &amp;fcn, const MnUserTransformation &amp;par, const MnStrategy &amp;stra)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~HessianGradientCalculator</name>
      <anchor>HessianGradientCalculatora1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual FunctionGradient</type>
      <name>operator()</name>
      <anchor>HessianGradientCalculatora2</anchor>
      <arglist>(const MinimumParameters &amp;) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual FunctionGradient</type>
      <name>operator()</name>
      <anchor>HessianGradientCalculatora3</anchor>
      <arglist>(const MinimumParameters &amp;, const FunctionGradient &amp;) const </arglist>
    </member>
    <member kind="function">
      <type>std::pair&lt; FunctionGradient, MnAlgebraicVector &gt;</type>
      <name>deltaGradient</name>
      <anchor>HessianGradientCalculatora4</anchor>
      <arglist>(const MinimumParameters &amp;, const FunctionGradient &amp;) const </arglist>
    </member>
    <member kind="function">
      <type>const MnFcn &amp;</type>
      <name>fcn</name>
      <anchor>HessianGradientCalculatora5</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const MnUserTransformation &amp;</type>
      <name>trafo</name>
      <anchor>HessianGradientCalculatora6</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const MnMachinePrecision &amp;</type>
      <name>precision</name>
      <anchor>HessianGradientCalculatora7</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const MnStrategy &amp;</type>
      <name>strategy</name>
      <anchor>HessianGradientCalculatora8</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>unsigned int</type>
      <name>ncycle</name>
      <anchor>HessianGradientCalculatora9</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>stepTolerance</name>
      <anchor>HessianGradientCalculatora10</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>gradTolerance</name>
      <anchor>HessianGradientCalculatora11</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="variable" protection="private">
      <type>const MnFcn &amp;</type>
      <name>theFcn</name>
      <anchor>HessianGradientCalculatorr0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>const MnUserTransformation &amp;</type>
      <name>theTransformation</name>
      <anchor>HessianGradientCalculatorr1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>const MnStrategy &amp;</type>
      <name>theStrategy</name>
      <anchor>HessianGradientCalculatorr2</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>InitialGradientCalculator</name>
    <filename>classInitialGradientCalculator.html</filename>
    <base>GradientCalculator</base>
    <member kind="function">
      <type></type>
      <name>InitialGradientCalculator</name>
      <anchor>InitialGradientCalculatora0</anchor>
      <arglist>(const MnFcn &amp;fcn, const MnUserTransformation &amp;par, const MnStrategy &amp;stra)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~InitialGradientCalculator</name>
      <anchor>InitialGradientCalculatora1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual FunctionGradient</type>
      <name>operator()</name>
      <anchor>InitialGradientCalculatora2</anchor>
      <arglist>(const MinimumParameters &amp;) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual FunctionGradient</type>
      <name>operator()</name>
      <anchor>InitialGradientCalculatora3</anchor>
      <arglist>(const MinimumParameters &amp;, const FunctionGradient &amp;) const </arglist>
    </member>
    <member kind="function">
      <type>const MnFcn &amp;</type>
      <name>fcn</name>
      <anchor>InitialGradientCalculatora4</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const MnUserTransformation &amp;</type>
      <name>trafo</name>
      <anchor>InitialGradientCalculatora5</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const MnMachinePrecision &amp;</type>
      <name>precision</name>
      <anchor>InitialGradientCalculatora6</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const MnStrategy &amp;</type>
      <name>strategy</name>
      <anchor>InitialGradientCalculatora7</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>unsigned int</type>
      <name>ncycle</name>
      <anchor>InitialGradientCalculatora8</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>stepTolerance</name>
      <anchor>InitialGradientCalculatora9</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>gradTolerance</name>
      <anchor>InitialGradientCalculatora10</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="variable" protection="private">
      <type>const MnFcn &amp;</type>
      <name>theFcn</name>
      <anchor>InitialGradientCalculatorr0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>const MnUserTransformation &amp;</type>
      <name>theTransformation</name>
      <anchor>InitialGradientCalculatorr1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>const MnStrategy &amp;</type>
      <name>theStrategy</name>
      <anchor>InitialGradientCalculatorr2</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>LASymMatrix</name>
    <filename>classLASymMatrix.html</filename>
    <member kind="typedef">
      <type>sym</type>
      <name>Type</name>
      <anchor>LASymMatrixw0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>LASymMatrix</name>
      <anchor>LASymMatrixa0</anchor>
      <arglist>(unsigned int n)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~LASymMatrix</name>
      <anchor>LASymMatrixa1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>LASymMatrix</name>
      <anchor>LASymMatrixa2</anchor>
      <arglist>(const LASymMatrix &amp;v)</arglist>
    </member>
    <member kind="function">
      <type>LASymMatrix &amp;</type>
      <name>operator=</name>
      <anchor>LASymMatrixa3</anchor>
      <arglist>(const LASymMatrix &amp;v)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>LASymMatrix</name>
      <anchor>LASymMatrixa4</anchor>
      <arglist>(const ABObj&lt; sym, LASymMatrix, T &gt; &amp;v)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>LASymMatrix</name>
      <anchor>LASymMatrixa5</anchor>
      <arglist>(const ABObj&lt; sym, ABSum&lt; ABObj&lt; sym, A, T &gt;, ABObj&lt; sym, B, T &gt; &gt;, T &gt; &amp;sum)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>LASymMatrix</name>
      <anchor>LASymMatrixa6</anchor>
      <arglist>(const ABObj&lt; sym, ABSum&lt; ABObj&lt; sym, LASymMatrix, T &gt;, ABObj&lt; sym, A, T &gt; &gt;, T &gt; &amp;sum)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>LASymMatrix</name>
      <anchor>LASymMatrixa7</anchor>
      <arglist>(const ABObj&lt; sym, ABObj&lt; sym, A, T &gt;, T &gt; &amp;something)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>LASymMatrix</name>
      <anchor>LASymMatrixa8</anchor>
      <arglist>(const ABObj&lt; sym, MatrixInverse&lt; sym, ABObj&lt; sym, LASymMatrix, T &gt;, T &gt;, T &gt; &amp;inv)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>LASymMatrix</name>
      <anchor>LASymMatrixa9</anchor>
      <arglist>(const ABObj&lt; sym, ABSum&lt; ABObj&lt; sym, MatrixInverse&lt; sym, ABObj&lt; sym, LASymMatrix, T &gt;, T &gt;, T &gt;, ABObj&lt; sym, A, T &gt; &gt;, T &gt; &amp;sum)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>LASymMatrix</name>
      <anchor>LASymMatrixa10</anchor>
      <arglist>(const ABObj&lt; sym, VectorOuterProduct&lt; ABObj&lt; vec, LAVector, double &gt;, double &gt;, double &gt; &amp;)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>LASymMatrix</name>
      <anchor>LASymMatrixa11</anchor>
      <arglist>(const ABObj&lt; sym, ABSum&lt; ABObj&lt; sym, VectorOuterProduct&lt; ABObj&lt; vec, LAVector, T &gt;, T &gt;, T &gt;, ABObj&lt; sym, A, T &gt; &gt;, T &gt; &amp;sum)</arglist>
    </member>
    <member kind="function">
      <type>LASymMatrix &amp;</type>
      <name>operator+=</name>
      <anchor>LASymMatrixa12</anchor>
      <arglist>(const LASymMatrix &amp;m)</arglist>
    </member>
    <member kind="function">
      <type>LASymMatrix &amp;</type>
      <name>operator-=</name>
      <anchor>LASymMatrixa13</anchor>
      <arglist>(const LASymMatrix &amp;m)</arglist>
    </member>
    <member kind="function">
      <type>LASymMatrix &amp;</type>
      <name>operator+=</name>
      <anchor>LASymMatrixa14</anchor>
      <arglist>(const ABObj&lt; sym, LASymMatrix, T &gt; &amp;m)</arglist>
    </member>
    <member kind="function">
      <type>LASymMatrix &amp;</type>
      <name>operator+=</name>
      <anchor>LASymMatrixa15</anchor>
      <arglist>(const ABObj&lt; sym, A, T &gt; &amp;m)</arglist>
    </member>
    <member kind="function">
      <type>LASymMatrix &amp;</type>
      <name>operator+=</name>
      <anchor>LASymMatrixa16</anchor>
      <arglist>(const ABObj&lt; sym, MatrixInverse&lt; sym, ABObj&lt; sym, LASymMatrix, T &gt;, T &gt;, T &gt; &amp;m)</arglist>
    </member>
    <member kind="function">
      <type>LASymMatrix &amp;</type>
      <name>operator+=</name>
      <anchor>LASymMatrixa17</anchor>
      <arglist>(const ABObj&lt; sym, VectorOuterProduct&lt; ABObj&lt; vec, LAVector, T &gt;, T &gt;, T &gt; &amp;m)</arglist>
    </member>
    <member kind="function">
      <type>LASymMatrix &amp;</type>
      <name>operator *=</name>
      <anchor>LASymMatrixa18</anchor>
      <arglist>(double scal)</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>operator()</name>
      <anchor>LASymMatrixa19</anchor>
      <arglist>(unsigned int row, unsigned int col) const </arglist>
    </member>
    <member kind="function">
      <type>double &amp;</type>
      <name>operator()</name>
      <anchor>LASymMatrixa20</anchor>
      <arglist>(unsigned int row, unsigned int col)</arglist>
    </member>
    <member kind="function">
      <type>const double *</type>
      <name>data</name>
      <anchor>LASymMatrixa21</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double *</type>
      <name>data</name>
      <anchor>LASymMatrixa22</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>unsigned int</type>
      <name>size</name>
      <anchor>LASymMatrixa23</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>unsigned int</type>
      <name>nrow</name>
      <anchor>LASymMatrixa24</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>unsigned int</type>
      <name>ncol</name>
      <anchor>LASymMatrixa25</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>LASymMatrix &amp;</type>
      <name>operator=</name>
      <anchor>LASymMatrixa26</anchor>
      <arglist>(const ABObj&lt; sym, LASymMatrix, T &gt; &amp;v)</arglist>
    </member>
    <member kind="function">
      <type>LASymMatrix &amp;</type>
      <name>operator=</name>
      <anchor>LASymMatrixa27</anchor>
      <arglist>(const ABObj&lt; sym, ABObj&lt; sym, A, T &gt;, T &gt; &amp;something)</arglist>
    </member>
    <member kind="function">
      <type>LASymMatrix &amp;</type>
      <name>operator=</name>
      <anchor>LASymMatrixa28</anchor>
      <arglist>(const ABObj&lt; sym, ABSum&lt; ABObj&lt; sym, A, T &gt;, ABObj&lt; sym, B, T &gt; &gt;, T &gt; &amp;sum)</arglist>
    </member>
    <member kind="function">
      <type>LASymMatrix &amp;</type>
      <name>operator=</name>
      <anchor>LASymMatrixa29</anchor>
      <arglist>(const ABObj&lt; sym, ABSum&lt; ABObj&lt; sym, LASymMatrix, T &gt;, ABObj&lt; sym, A, T &gt; &gt;, T &gt; &amp;sum)</arglist>
    </member>
    <member kind="function">
      <type>LASymMatrix &amp;</type>
      <name>operator=</name>
      <anchor>LASymMatrixa30</anchor>
      <arglist>(const ABObj&lt; sym, MatrixInverse&lt; sym, ABObj&lt; sym, LASymMatrix, T &gt;, T &gt;, T &gt; &amp;inv)</arglist>
    </member>
    <member kind="function">
      <type>LASymMatrix &amp;</type>
      <name>operator=</name>
      <anchor>LASymMatrixa31</anchor>
      <arglist>(const ABObj&lt; sym, VectorOuterProduct&lt; ABObj&lt; vec, LAVector, double &gt;, double &gt;, double &gt; &amp;)</arglist>
    </member>
    <member kind="function" protection="private">
      <type></type>
      <name>LASymMatrix</name>
      <anchor>LASymMatrixd0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>unsigned int</type>
      <name>theSize</name>
      <anchor>LASymMatrixr0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>unsigned int</type>
      <name>theNRow</name>
      <anchor>LASymMatrixr1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double *</type>
      <name>theData</name>
      <anchor>LASymMatrixr2</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>LAVector</name>
    <filename>classLAVector.html</filename>
    <member kind="typedef">
      <type>vec</type>
      <name>Type</name>
      <anchor>LAVectorw0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>LAVector</name>
      <anchor>LAVectora0</anchor>
      <arglist>(unsigned int n)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~LAVector</name>
      <anchor>LAVectora1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>LAVector</name>
      <anchor>LAVectora2</anchor>
      <arglist>(const LAVector &amp;v)</arglist>
    </member>
    <member kind="function">
      <type>LAVector &amp;</type>
      <name>operator=</name>
      <anchor>LAVectora3</anchor>
      <arglist>(const LAVector &amp;v)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>LAVector</name>
      <anchor>LAVectora4</anchor>
      <arglist>(const ABObj&lt; vec, LAVector, T &gt; &amp;v)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>LAVector</name>
      <anchor>LAVectora5</anchor>
      <arglist>(const ABObj&lt; vec, ABSum&lt; ABObj&lt; vec, A, T &gt;, ABObj&lt; vec, B, T &gt; &gt;, T &gt; &amp;sum)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>LAVector</name>
      <anchor>LAVectora6</anchor>
      <arglist>(const ABObj&lt; vec, ABSum&lt; ABObj&lt; vec, LAVector, T &gt;, ABObj&lt; vec, A, T &gt; &gt;, T &gt; &amp;sum)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>LAVector</name>
      <anchor>LAVectora7</anchor>
      <arglist>(const ABObj&lt; vec, ABObj&lt; vec, A, T &gt;, T &gt; &amp;something)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>LAVector</name>
      <anchor>LAVectora8</anchor>
      <arglist>(const ABObj&lt; vec, ABProd&lt; ABObj&lt; sym, LASymMatrix, T &gt;, ABObj&lt; vec, LAVector, T &gt; &gt;, T &gt; &amp;prod)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>LAVector</name>
      <anchor>LAVectora9</anchor>
      <arglist>(const ABObj&lt; vec, ABSum&lt; ABObj&lt; vec, ABProd&lt; ABObj&lt; sym, LASymMatrix, T &gt;, ABObj&lt; vec, LAVector, T &gt; &gt;, T &gt;, ABObj&lt; vec, LAVector, T &gt; &gt;, T &gt; &amp;prod)</arglist>
    </member>
    <member kind="function">
      <type>LAVector &amp;</type>
      <name>operator+=</name>
      <anchor>LAVectora10</anchor>
      <arglist>(const LAVector &amp;m)</arglist>
    </member>
    <member kind="function">
      <type>LAVector &amp;</type>
      <name>operator-=</name>
      <anchor>LAVectora11</anchor>
      <arglist>(const LAVector &amp;m)</arglist>
    </member>
    <member kind="function">
      <type>LAVector &amp;</type>
      <name>operator+=</name>
      <anchor>LAVectora12</anchor>
      <arglist>(const ABObj&lt; vec, LAVector, T &gt; &amp;m)</arglist>
    </member>
    <member kind="function">
      <type>LAVector &amp;</type>
      <name>operator+=</name>
      <anchor>LAVectora13</anchor>
      <arglist>(const ABObj&lt; vec, A, T &gt; &amp;m)</arglist>
    </member>
    <member kind="function">
      <type>LAVector &amp;</type>
      <name>operator+=</name>
      <anchor>LAVectora14</anchor>
      <arglist>(const ABObj&lt; vec, ABProd&lt; ABObj&lt; sym, LASymMatrix, T &gt;, ABObj&lt; vec, LAVector, T &gt; &gt;, T &gt; &amp;prod)</arglist>
    </member>
    <member kind="function">
      <type>LAVector &amp;</type>
      <name>operator *=</name>
      <anchor>LAVectora15</anchor>
      <arglist>(double scal)</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>operator()</name>
      <anchor>LAVectora16</anchor>
      <arglist>(unsigned int i) const </arglist>
    </member>
    <member kind="function">
      <type>double &amp;</type>
      <name>operator()</name>
      <anchor>LAVectora17</anchor>
      <arglist>(unsigned int i)</arglist>
    </member>
    <member kind="function">
      <type>const double *</type>
      <name>data</name>
      <anchor>LAVectora18</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double *</type>
      <name>data</name>
      <anchor>LAVectora19</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>unsigned int</type>
      <name>size</name>
      <anchor>LAVectora20</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>LAVector &amp;</type>
      <name>operator=</name>
      <anchor>LAVectora21</anchor>
      <arglist>(const ABObj&lt; vec, LAVector, T &gt; &amp;v)</arglist>
    </member>
    <member kind="function">
      <type>LAVector &amp;</type>
      <name>operator=</name>
      <anchor>LAVectora22</anchor>
      <arglist>(const ABObj&lt; vec, ABObj&lt; vec, A, T &gt;, T &gt; &amp;something)</arglist>
    </member>
    <member kind="function">
      <type>LAVector &amp;</type>
      <name>operator=</name>
      <anchor>LAVectora23</anchor>
      <arglist>(const ABObj&lt; vec, ABSum&lt; ABObj&lt; vec, A, T &gt;, ABObj&lt; vec, B, T &gt; &gt;, T &gt; &amp;sum)</arglist>
    </member>
    <member kind="function">
      <type>LAVector &amp;</type>
      <name>operator=</name>
      <anchor>LAVectora24</anchor>
      <arglist>(const ABObj&lt; vec, ABSum&lt; ABObj&lt; vec, LAVector, T &gt;, ABObj&lt; vec, A, T &gt; &gt;, T &gt; &amp;sum)</arglist>
    </member>
    <member kind="function">
      <type>LAVector &amp;</type>
      <name>operator=</name>
      <anchor>LAVectora25</anchor>
      <arglist>(const ABObj&lt; vec, ABProd&lt; ABObj&lt; sym, LASymMatrix, T &gt;, ABObj&lt; vec, LAVector, T &gt; &gt;, T &gt; &amp;prod)</arglist>
    </member>
    <member kind="function">
      <type>LAVector &amp;</type>
      <name>operator=</name>
      <anchor>LAVectora26</anchor>
      <arglist>(const ABObj&lt; vec, ABSum&lt; ABObj&lt; vec, ABProd&lt; ABObj&lt; sym, LASymMatrix, T &gt;, ABObj&lt; vec, LAVector, T &gt; &gt;, T &gt;, ABObj&lt; vec, LAVector, T &gt; &gt;, T &gt; &amp;prod)</arglist>
    </member>
    <member kind="function" protection="private">
      <type></type>
      <name>LAVector</name>
      <anchor>LAVectord0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>unsigned int</type>
      <name>theSize</name>
      <anchor>LAVectorr0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double *</type>
      <name>theData</name>
      <anchor>LAVectorr1</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>MatrixInverse</name>
    <filename>classMatrixInverse.html</filename>
    <templarg>mtype</templarg>
    <templarg>M</templarg>
    <templarg>T</templarg>
    <member kind="typedef">
      <type>mtype</type>
      <name>Type</name>
      <anchor>MatrixInversew0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>MatrixInverse</name>
      <anchor>MatrixInversea0</anchor>
      <arglist>(const M &amp;obj)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~MatrixInverse</name>
      <anchor>MatrixInversea1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>const M &amp;</type>
      <name>obj</name>
      <anchor>MatrixInversea2</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="variable" protection="private">
      <type>M</type>
      <name>theObject</name>
      <anchor>MatrixInverser0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>MatrixInverse&lt; vec, M, T &gt;</name>
    <filename>classMatrixInverse_3_01vec_00_01M_00_01T_01_4.html</filename>
    <templarg>M</templarg>
    <templarg>T</templarg>
    <member kind="typedef">
      <type>vec</type>
      <name>Type</name>
      <anchor>MatrixInverse_3_01vec_00_01M_00_01T_01_4w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~MatrixInverse</name>
      <anchor>MatrixInverse_3_01vec_00_01M_00_01T_01_4a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>const M &amp;</type>
      <name>obj</name>
      <anchor>MatrixInverse_3_01vec_00_01M_00_01T_01_4a1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="private">
      <type></type>
      <name>MatrixInverse</name>
      <anchor>MatrixInverse_3_01vec_00_01M_00_01T_01_4d0</anchor>
      <arglist>(const M &amp;obj)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>M</type>
      <name>theObject</name>
      <anchor>MatrixInverse_3_01vec_00_01M_00_01T_01_4r0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>MinimumBuilder</name>
    <filename>classMinimumBuilder.html</filename>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~MinimumBuilder</name>
      <anchor>MinimumBuildera0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual FunctionMinimum</type>
      <name>minimum</name>
      <anchor>MinimumBuildera1</anchor>
      <arglist>(const MnFcn &amp;, const GradientCalculator &amp;, const MinimumSeed &amp;, const MnStrategy &amp;, unsigned int, double) const =0</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>MinimumError</name>
    <filename>classMinimumError.html</filename>
    <member kind="function">
      <type></type>
      <name>MinimumError</name>
      <anchor>MinimumErrora0</anchor>
      <arglist>(unsigned int n)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>MinimumError</name>
      <anchor>MinimumErrora1</anchor>
      <arglist>(const MnAlgebraicSymMatrix &amp;mat, double dcov)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>MinimumError</name>
      <anchor>MinimumErrora2</anchor>
      <arglist>(const MnAlgebraicSymMatrix &amp;mat, MnHesseFailed)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>MinimumError</name>
      <anchor>MinimumErrora3</anchor>
      <arglist>(const MnAlgebraicSymMatrix &amp;mat, MnMadePosDef)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>MinimumError</name>
      <anchor>MinimumErrora4</anchor>
      <arglist>(const MnAlgebraicSymMatrix &amp;mat, MnInvertFailed)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>MinimumError</name>
      <anchor>MinimumErrora5</anchor>
      <arglist>(const MnAlgebraicSymMatrix &amp;mat, MnNotPosDef)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~MinimumError</name>
      <anchor>MinimumErrora6</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>MinimumError</name>
      <anchor>MinimumErrora7</anchor>
      <arglist>(const MinimumError &amp;e)</arglist>
    </member>
    <member kind="function">
      <type>MinimumError &amp;</type>
      <name>operator=</name>
      <anchor>MinimumErrora8</anchor>
      <arglist>(const MinimumError &amp;err)</arglist>
    </member>
    <member kind="function">
      <type>MnAlgebraicSymMatrix</type>
      <name>matrix</name>
      <anchor>MinimumErrora9</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const MnAlgebraicSymMatrix &amp;</type>
      <name>invHessian</name>
      <anchor>MinimumErrora10</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>MnAlgebraicSymMatrix</type>
      <name>hessian</name>
      <anchor>MinimumErrora11</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>dcovar</name>
      <anchor>MinimumErrora12</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>isAccurate</name>
      <anchor>MinimumErrora13</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>isValid</name>
      <anchor>MinimumErrora14</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>isPosDef</name>
      <anchor>MinimumErrora15</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>isMadePosDef</name>
      <anchor>MinimumErrora16</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>hesseFailed</name>
      <anchor>MinimumErrora17</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>invertFailed</name>
      <anchor>MinimumErrora18</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>isAvailable</name>
      <anchor>MinimumErrora19</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="variable" protection="private">
      <type>MnRefCountedPointer&lt; BasicMinimumError &gt;</type>
      <name>theData</name>
      <anchor>MinimumErrorr0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>MinimumError::MnHesseFailed</name>
    <filename>classMinimumError_1_1MnHesseFailed.html</filename>
  </compound>
  <compound kind="class">
    <name>MinimumError::MnInvertFailed</name>
    <filename>classMinimumError_1_1MnInvertFailed.html</filename>
  </compound>
  <compound kind="class">
    <name>MinimumError::MnMadePosDef</name>
    <filename>classMinimumError_1_1MnMadePosDef.html</filename>
  </compound>
  <compound kind="class">
    <name>MinimumError::MnNotPosDef</name>
    <filename>classMinimumError_1_1MnNotPosDef.html</filename>
  </compound>
  <compound kind="class">
    <name>MinimumErrorUpdator</name>
    <filename>classMinimumErrorUpdator.html</filename>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~MinimumErrorUpdator</name>
      <anchor>MinimumErrorUpdatora0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual MinimumError</type>
      <name>update</name>
      <anchor>MinimumErrorUpdatora1</anchor>
      <arglist>(const MinimumState &amp;, const MinimumParameters &amp;, const FunctionGradient &amp;) const =0</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>MinimumParameters</name>
    <filename>classMinimumParameters.html</filename>
    <member kind="function">
      <type></type>
      <name>MinimumParameters</name>
      <anchor>MinimumParametersa0</anchor>
      <arglist>(unsigned int n)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>MinimumParameters</name>
      <anchor>MinimumParametersa1</anchor>
      <arglist>(const MnAlgebraicVector &amp;avec, double fval)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>MinimumParameters</name>
      <anchor>MinimumParametersa2</anchor>
      <arglist>(const MnAlgebraicVector &amp;avec, const MnAlgebraicVector &amp;dirin, double fval)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~MinimumParameters</name>
      <anchor>MinimumParametersa3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>MinimumParameters</name>
      <anchor>MinimumParametersa4</anchor>
      <arglist>(const MinimumParameters &amp;par)</arglist>
    </member>
    <member kind="function">
      <type>MinimumParameters &amp;</type>
      <name>operator=</name>
      <anchor>MinimumParametersa5</anchor>
      <arglist>(const MinimumParameters &amp;par)</arglist>
    </member>
    <member kind="function">
      <type>const MnAlgebraicVector &amp;</type>
      <name>vec</name>
      <anchor>MinimumParametersa6</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const MnAlgebraicVector &amp;</type>
      <name>dirin</name>
      <anchor>MinimumParametersa7</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>fval</name>
      <anchor>MinimumParametersa8</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>isValid</name>
      <anchor>MinimumParametersa9</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>hasStepSize</name>
      <anchor>MinimumParametersa10</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="variable" protection="private">
      <type>MnRefCountedPointer&lt; BasicMinimumParameters &gt;</type>
      <name>theData</name>
      <anchor>MinimumParametersr0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>MinimumSeed</name>
    <filename>classMinimumSeed.html</filename>
    <member kind="function">
      <type></type>
      <name>MinimumSeed</name>
      <anchor>MinimumSeeda0</anchor>
      <arglist>(const MinimumState &amp;st, const MnUserTransformation &amp;trafo)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~MinimumSeed</name>
      <anchor>MinimumSeeda1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>MinimumSeed</name>
      <anchor>MinimumSeeda2</anchor>
      <arglist>(const MinimumSeed &amp;seed)</arglist>
    </member>
    <member kind="function">
      <type>MinimumSeed &amp;</type>
      <name>operator=</name>
      <anchor>MinimumSeeda3</anchor>
      <arglist>(const MinimumSeed &amp;seed)</arglist>
    </member>
    <member kind="function">
      <type>const MinimumState &amp;</type>
      <name>state</name>
      <anchor>MinimumSeeda4</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const MinimumParameters &amp;</type>
      <name>parameters</name>
      <anchor>MinimumSeeda5</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const MinimumError &amp;</type>
      <name>error</name>
      <anchor>MinimumSeeda6</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const FunctionGradient &amp;</type>
      <name>gradient</name>
      <anchor>MinimumSeeda7</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const MnUserTransformation &amp;</type>
      <name>trafo</name>
      <anchor>MinimumSeeda8</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const MnMachinePrecision &amp;</type>
      <name>precision</name>
      <anchor>MinimumSeeda9</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>fval</name>
      <anchor>MinimumSeeda10</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>edm</name>
      <anchor>MinimumSeeda11</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>unsigned int</type>
      <name>nfcn</name>
      <anchor>MinimumSeeda12</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>isValid</name>
      <anchor>MinimumSeeda13</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="variable" protection="private">
      <type>MnRefCountedPointer&lt; BasicMinimumSeed &gt;</type>
      <name>theData</name>
      <anchor>MinimumSeedr0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>MinimumSeedGenerator</name>
    <filename>classMinimumSeedGenerator.html</filename>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~MinimumSeedGenerator</name>
      <anchor>MinimumSeedGeneratora0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual MinimumSeed</type>
      <name>operator()</name>
      <anchor>MinimumSeedGeneratora1</anchor>
      <arglist>(const MnFcn &amp;, const GradientCalculator &amp;, const MnUserParameterState &amp;, const MnStrategy &amp;) const =0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual MinimumSeed</type>
      <name>operator()</name>
      <anchor>MinimumSeedGeneratora2</anchor>
      <arglist>(const MnFcn &amp;, const AnalyticalGradientCalculator &amp;, const MnUserParameterState &amp;, const MnStrategy &amp;) const =0</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>MinimumState</name>
    <filename>classMinimumState.html</filename>
    <member kind="function">
      <type></type>
      <name>MinimumState</name>
      <anchor>MinimumStatea0</anchor>
      <arglist>(unsigned int n)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>MinimumState</name>
      <anchor>MinimumStatea1</anchor>
      <arglist>(const MinimumParameters &amp;states, double edm, int nfcn)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>MinimumState</name>
      <anchor>MinimumStatea2</anchor>
      <arglist>(const MinimumParameters &amp;states, const MinimumError &amp;err, const FunctionGradient &amp;grad, double edm, int nfcn)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~MinimumState</name>
      <anchor>MinimumStatea3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>MinimumState</name>
      <anchor>MinimumStatea4</anchor>
      <arglist>(const MinimumState &amp;state)</arglist>
    </member>
    <member kind="function">
      <type>MinimumState &amp;</type>
      <name>operator=</name>
      <anchor>MinimumStatea5</anchor>
      <arglist>(const MinimumState &amp;state)</arglist>
    </member>
    <member kind="function">
      <type>const MinimumParameters &amp;</type>
      <name>parameters</name>
      <anchor>MinimumStatea6</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const MnAlgebraicVector &amp;</type>
      <name>vec</name>
      <anchor>MinimumStatea7</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>size</name>
      <anchor>MinimumStatea8</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const MinimumError &amp;</type>
      <name>error</name>
      <anchor>MinimumStatea9</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const FunctionGradient &amp;</type>
      <name>gradient</name>
      <anchor>MinimumStatea10</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>fval</name>
      <anchor>MinimumStatea11</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>edm</name>
      <anchor>MinimumStatea12</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>nfcn</name>
      <anchor>MinimumStatea13</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>isValid</name>
      <anchor>MinimumStatea14</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>hasParameters</name>
      <anchor>MinimumStatea15</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>hasCovariance</name>
      <anchor>MinimumStatea16</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="variable" protection="private">
      <type>MnRefCountedPointer&lt; BasicMinimumState &gt;</type>
      <name>theData</name>
      <anchor>MinimumStater0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>MinosError</name>
    <filename>classMinosError.html</filename>
    <member kind="function">
      <type></type>
      <name>MinosError</name>
      <anchor>MinosErrora0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>MinosError</name>
      <anchor>MinosErrora1</anchor>
      <arglist>(unsigned int par, double min, const MnCross &amp;low, const MnCross &amp;up)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~MinosError</name>
      <anchor>MinosErrora2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>MinosError</name>
      <anchor>MinosErrora3</anchor>
      <arglist>(const MinosError &amp;err)</arglist>
    </member>
    <member kind="function">
      <type>MinosError &amp;</type>
      <name>operator()</name>
      <anchor>MinosErrora4</anchor>
      <arglist>(const MinosError &amp;err)</arglist>
    </member>
    <member kind="function">
      <type>std::pair&lt; double, double &gt;</type>
      <name>operator()</name>
      <anchor>MinosErrora5</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>lower</name>
      <anchor>MinosErrora6</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>upper</name>
      <anchor>MinosErrora7</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>unsigned int</type>
      <name>parameter</name>
      <anchor>MinosErrora8</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const MnUserParameterState &amp;</type>
      <name>lowerState</name>
      <anchor>MinosErrora9</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const MnUserParameterState &amp;</type>
      <name>upperState</name>
      <anchor>MinosErrora10</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>isValid</name>
      <anchor>MinosErrora11</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>lowerValid</name>
      <anchor>MinosErrora12</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>upperValid</name>
      <anchor>MinosErrora13</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>atLowerLimit</name>
      <anchor>MinosErrora14</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>atUpperLimit</name>
      <anchor>MinosErrora15</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>atLowerMaxFcn</name>
      <anchor>MinosErrora16</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>atUpperMaxFcn</name>
      <anchor>MinosErrora17</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>lowerNewMin</name>
      <anchor>MinosErrora18</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>upperNewMin</name>
      <anchor>MinosErrora19</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>unsigned int</type>
      <name>nfcn</name>
      <anchor>MinosErrora20</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>min</name>
      <anchor>MinosErrora21</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="variable" protection="private">
      <type>unsigned int</type>
      <name>theParameter</name>
      <anchor>MinosErrorr0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theMinValue</name>
      <anchor>MinosErrorr1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>MnCross</type>
      <name>theUpper</name>
      <anchor>MinosErrorr2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>MnCross</type>
      <name>theLower</name>
      <anchor>MinosErrorr3</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>MinuitParameter</name>
    <filename>classMinuitParameter.html</filename>
    <member kind="function">
      <type></type>
      <name>MinuitParameter</name>
      <anchor>MinuitParametera0</anchor>
      <arglist>(unsigned int num, const char *name, double val)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>MinuitParameter</name>
      <anchor>MinuitParametera1</anchor>
      <arglist>(unsigned int num, const char *name, double val, double err)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>MinuitParameter</name>
      <anchor>MinuitParametera2</anchor>
      <arglist>(unsigned int num, const char *name, double val, double err, double min, double max)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~MinuitParameter</name>
      <anchor>MinuitParametera3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>MinuitParameter</name>
      <anchor>MinuitParametera4</anchor>
      <arglist>(const MinuitParameter &amp;par)</arglist>
    </member>
    <member kind="function">
      <type>MinuitParameter &amp;</type>
      <name>operator=</name>
      <anchor>MinuitParametera5</anchor>
      <arglist>(const MinuitParameter &amp;par)</arglist>
    </member>
    <member kind="function">
      <type>unsigned int</type>
      <name>number</name>
      <anchor>MinuitParametera6</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const char *</type>
      <name>name</name>
      <anchor>MinuitParametera7</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>value</name>
      <anchor>MinuitParametera8</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>error</name>
      <anchor>MinuitParametera9</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setValue</name>
      <anchor>MinuitParametera10</anchor>
      <arglist>(double val)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setError</name>
      <anchor>MinuitParametera11</anchor>
      <arglist>(double err)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setLimits</name>
      <anchor>MinuitParametera12</anchor>
      <arglist>(double low, double up)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setUpperLimit</name>
      <anchor>MinuitParametera13</anchor>
      <arglist>(double up)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setLowerLimit</name>
      <anchor>MinuitParametera14</anchor>
      <arglist>(double low)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>removeLimits</name>
      <anchor>MinuitParametera15</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>fix</name>
      <anchor>MinuitParametera16</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>release</name>
      <anchor>MinuitParametera17</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>isConst</name>
      <anchor>MinuitParametera18</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>isFixed</name>
      <anchor>MinuitParametera19</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>hasLimits</name>
      <anchor>MinuitParametera20</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>hasLowerLimit</name>
      <anchor>MinuitParametera21</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>hasUpperLimit</name>
      <anchor>MinuitParametera22</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>lowerLimit</name>
      <anchor>MinuitParametera23</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>upperLimit</name>
      <anchor>MinuitParametera24</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>setName</name>
      <anchor>MinuitParameterd0</anchor>
      <arglist>(const char *name)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>unsigned int</type>
      <name>theNum</name>
      <anchor>MinuitParameterr0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>char</type>
      <name>theName</name>
      <anchor>MinuitParameterr1</anchor>
      <arglist>[11]</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theValue</name>
      <anchor>MinuitParameterr2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theError</name>
      <anchor>MinuitParameterr3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool</type>
      <name>theConst</name>
      <anchor>MinuitParameterr4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool</type>
      <name>theFix</name>
      <anchor>MinuitParameterr5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theLoLimit</name>
      <anchor>MinuitParameterr6</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theUpLimit</name>
      <anchor>MinuitParameterr7</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool</type>
      <name>theLoLimValid</name>
      <anchor>MinuitParameterr8</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool</type>
      <name>theUpLimValid</name>
      <anchor>MinuitParameterr9</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>MnApplication</name>
    <filename>classMnApplication.html</filename>
    <member kind="function">
      <type></type>
      <name>MnApplication</name>
      <anchor>MnApplicationa0</anchor>
      <arglist>(const FCNBase &amp;fcn, const MnUserParameterState &amp;state, const MnStrategy &amp;stra)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>MnApplication</name>
      <anchor>MnApplicationa1</anchor>
      <arglist>(const FCNBase &amp;fcn, const MnUserParameterState &amp;state, const MnStrategy &amp;stra, unsigned int nfcn)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~MnApplication</name>
      <anchor>MnApplicationa2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual FunctionMinimum</type>
      <name>operator()</name>
      <anchor>MnSimplexa9</anchor>
      <arglist>(unsigned int=0, double=0.1)</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual const ModularFunctionMinimizer &amp;</type>
      <name>minimizer</name>
      <anchor>MnApplicationa4</anchor>
      <arglist>() const =0</arglist>
    </member>
    <member kind="function">
      <type>const MnMachinePrecision &amp;</type>
      <name>precision</name>
      <anchor>MnSimplexa10</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const MnUserParameterState &amp;</type>
      <name>state</name>
      <anchor>MnSimplexa11</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const MnUserParameters &amp;</type>
      <name>parameters</name>
      <anchor>MnSimplexa12</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const MnUserCovariance &amp;</type>
      <name>covariance</name>
      <anchor>MnSimplexa13</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const FCNBase &amp;</type>
      <name>fcnbase</name>
      <anchor>MnSimplexa14</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const MnStrategy &amp;</type>
      <name>strategy</name>
      <anchor>MnSimplexa15</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>unsigned int</type>
      <name>numOfCalls</name>
      <anchor>MnSimplexa16</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const std::vector&lt; MinuitParameter &gt; &amp;</type>
      <name>minuitParameters</name>
      <anchor>MnSimplexa17</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>std::vector&lt; double &gt;</type>
      <name>params</name>
      <anchor>MnSimplexa18</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>std::vector&lt; double &gt;</type>
      <name>errors</name>
      <anchor>MnSimplexa19</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const MinuitParameter &amp;</type>
      <name>parameter</name>
      <anchor>MnSimplexa20</anchor>
      <arglist>(unsigned int i) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>add</name>
      <anchor>MnSimplexa21</anchor>
      <arglist>(const char *name, double val, double err)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>add</name>
      <anchor>MnSimplexa22</anchor>
      <arglist>(const char *name, double val, double err, double, double)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>add</name>
      <anchor>MnSimplexa23</anchor>
      <arglist>(const char *, double)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>fix</name>
      <anchor>MnSimplexa24</anchor>
      <arglist>(unsigned int)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>release</name>
      <anchor>MnSimplexa26</anchor>
      <arglist>(unsigned int)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setValue</name>
      <anchor>MnSimplexa28</anchor>
      <arglist>(unsigned int, double)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setError</name>
      <anchor>MnSimplexa30</anchor>
      <arglist>(unsigned int, double)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setLimits</name>
      <anchor>MnSimplexa32</anchor>
      <arglist>(unsigned int, double, double)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>removeLimits</name>
      <anchor>MnSimplexa34</anchor>
      <arglist>(unsigned int)</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>value</name>
      <anchor>MnSimplexa36</anchor>
      <arglist>(unsigned int) const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>error</name>
      <anchor>MnSimplexa38</anchor>
      <arglist>(unsigned int) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>fix</name>
      <anchor>MnSimplexa25</anchor>
      <arglist>(const char *)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>release</name>
      <anchor>MnSimplexa27</anchor>
      <arglist>(const char *)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setValue</name>
      <anchor>MnSimplexa29</anchor>
      <arglist>(const char *, double)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setError</name>
      <anchor>MnSimplexa31</anchor>
      <arglist>(const char *, double)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setLimits</name>
      <anchor>MnSimplexa33</anchor>
      <arglist>(const char *, double, double)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>removeLimits</name>
      <anchor>MnSimplexa35</anchor>
      <arglist>(const char *)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setPrecision</name>
      <anchor>MnSimplexa40</anchor>
      <arglist>(double)</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>value</name>
      <anchor>MnSimplexa37</anchor>
      <arglist>(const char *) const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>error</name>
      <anchor>MnSimplexa39</anchor>
      <arglist>(const char *) const </arglist>
    </member>
    <member kind="function">
      <type>unsigned int</type>
      <name>index</name>
      <anchor>MnSimplexa41</anchor>
      <arglist>(const char *) const </arglist>
    </member>
    <member kind="function">
      <type>const char *</type>
      <name>name</name>
      <anchor>MnSimplexa42</anchor>
      <arglist>(unsigned int) const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>int2ext</name>
      <anchor>MnSimplexa43</anchor>
      <arglist>(unsigned int, double) const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>ext2int</name>
      <anchor>MnSimplexa44</anchor>
      <arglist>(unsigned int, double) const </arglist>
    </member>
    <member kind="function">
      <type>unsigned int</type>
      <name>intOfExt</name>
      <anchor>MnSimplexa45</anchor>
      <arglist>(unsigned int) const </arglist>
    </member>
    <member kind="function">
      <type>unsigned int</type>
      <name>extOfInt</name>
      <anchor>MnSimplexa46</anchor>
      <arglist>(unsigned int) const </arglist>
    </member>
    <member kind="function">
      <type>unsigned int</type>
      <name>variableParameters</name>
      <anchor>MnSimplexa47</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>const FCNBase &amp;</type>
      <name>theFCN</name>
      <anchor>MnSimplexp0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>MnUserParameterState</type>
      <name>theState</name>
      <anchor>MnSimplexp1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>MnStrategy</type>
      <name>theStrategy</name>
      <anchor>MnSimplexp2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>unsigned int</type>
      <name>theNumCall</name>
      <anchor>MnSimplexp3</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>MnContours</name>
    <filename>classMnContours.html</filename>
    <member kind="function">
      <type></type>
      <name>MnContours</name>
      <anchor>MnContoursa0</anchor>
      <arglist>(const FCNBase &amp;fcn, const FunctionMinimum &amp;min)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>MnContours</name>
      <anchor>MnContoursa1</anchor>
      <arglist>(const FCNBase &amp;fcn, const FunctionMinimum &amp;min, unsigned int stra)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>MnContours</name>
      <anchor>MnContoursa2</anchor>
      <arglist>(const FCNBase &amp;fcn, const FunctionMinimum &amp;min, const MnStrategy &amp;stra)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~MnContours</name>
      <anchor>MnContoursa3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>std::vector&lt; std::pair&lt; double, double &gt; &gt;</type>
      <name>operator()</name>
      <anchor>MnContoursa4</anchor>
      <arglist>(unsigned int, unsigned int, unsigned int npoints=20) const </arglist>
    </member>
    <member kind="function">
      <type>ContoursError</type>
      <name>contour</name>
      <anchor>MnContoursa5</anchor>
      <arglist>(unsigned int, unsigned int, unsigned int npoints=20) const </arglist>
    </member>
    <member kind="function">
      <type>const MnStrategy &amp;</type>
      <name>strategy</name>
      <anchor>MnContoursa6</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="variable" protection="private">
      <type>const FCNBase &amp;</type>
      <name>theFCN</name>
      <anchor>MnContoursr0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>const FunctionMinimum &amp;</type>
      <name>theMinimum</name>
      <anchor>MnContoursr1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>MnStrategy</type>
      <name>theStrategy</name>
      <anchor>MnContoursr2</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>MnCovarianceSqueeze</name>
    <filename>classMnCovarianceSqueeze.html</filename>
    <member kind="function">
      <type></type>
      <name>MnCovarianceSqueeze</name>
      <anchor>MnCovarianceSqueezea0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~MnCovarianceSqueeze</name>
      <anchor>MnCovarianceSqueezea1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>MnUserCovariance</type>
      <name>operator()</name>
      <anchor>MnCovarianceSqueezea2</anchor>
      <arglist>(const MnUserCovariance &amp;, unsigned int) const </arglist>
    </member>
    <member kind="function">
      <type>MinimumError</type>
      <name>operator()</name>
      <anchor>MnCovarianceSqueezea3</anchor>
      <arglist>(const MinimumError &amp;, unsigned int) const </arglist>
    </member>
    <member kind="function">
      <type>MnAlgebraicSymMatrix</type>
      <name>operator()</name>
      <anchor>MnCovarianceSqueezea4</anchor>
      <arglist>(const MnAlgebraicSymMatrix &amp;, unsigned int) const </arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>MnCross</name>
    <filename>classMnCross.html</filename>
    <member kind="function">
      <type></type>
      <name>MnCross</name>
      <anchor>MnCrossa0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>MnCross</name>
      <anchor>MnCrossa1</anchor>
      <arglist>(unsigned int nfcn)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>MnCross</name>
      <anchor>MnCrossa2</anchor>
      <arglist>(double value, const MnUserParameterState &amp;state, unsigned int nfcn)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>MnCross</name>
      <anchor>MnCrossa3</anchor>
      <arglist>(const MnUserParameterState &amp;state, unsigned int nfcn, CrossParLimit)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>MnCross</name>
      <anchor>MnCrossa4</anchor>
      <arglist>(const MnUserParameterState &amp;state, unsigned int nfcn, CrossFcnLimit)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>MnCross</name>
      <anchor>MnCrossa5</anchor>
      <arglist>(const MnUserParameterState &amp;state, unsigned int nfcn, CrossNewMin)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~MnCross</name>
      <anchor>MnCrossa6</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>MnCross</name>
      <anchor>MnCrossa7</anchor>
      <arglist>(const MnCross &amp;cross)</arglist>
    </member>
    <member kind="function">
      <type>MnCross &amp;</type>
      <name>operator()</name>
      <anchor>MnCrossa8</anchor>
      <arglist>(const MnCross &amp;cross)</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>value</name>
      <anchor>MnCrossa9</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const MnUserParameterState &amp;</type>
      <name>state</name>
      <anchor>MnCrossa10</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>isValid</name>
      <anchor>MnCrossa11</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>atLimit</name>
      <anchor>MnCrossa12</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>atMaxFcn</name>
      <anchor>MnCrossa13</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>newMinimum</name>
      <anchor>MnCrossa14</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>unsigned int</type>
      <name>nfcn</name>
      <anchor>MnCrossa15</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theValue</name>
      <anchor>MnCrossr0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>MnUserParameterState</type>
      <name>theState</name>
      <anchor>MnCrossr1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>unsigned int</type>
      <name>theNFcn</name>
      <anchor>MnCrossr2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool</type>
      <name>theValid</name>
      <anchor>MnCrossr3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool</type>
      <name>theLimset</name>
      <anchor>MnCrossr4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool</type>
      <name>theMaxFcn</name>
      <anchor>MnCrossr5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool</type>
      <name>theNewMin</name>
      <anchor>MnCrossr6</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>MnCross::CrossFcnLimit</name>
    <filename>classMnCross_1_1CrossFcnLimit.html</filename>
  </compound>
  <compound kind="class">
    <name>MnCross::CrossNewMin</name>
    <filename>classMnCross_1_1CrossNewMin.html</filename>
  </compound>
  <compound kind="class">
    <name>MnCross::CrossParLimit</name>
    <filename>classMnCross_1_1CrossParLimit.html</filename>
  </compound>
  <compound kind="class">
    <name>MnEigen</name>
    <filename>classMnEigen.html</filename>
    <member kind="function">
      <type></type>
      <name>MnEigen</name>
      <anchor>MnEigena0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~MnEigen</name>
      <anchor>MnEigena1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>std::vector&lt; double &gt;</type>
      <name>operator()</name>
      <anchor>MnEigena2</anchor>
      <arglist>(const MnUserCovariance &amp;) const </arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>MnFcn</name>
    <filename>classMnFcn.html</filename>
    <member kind="function">
      <type></type>
      <name>MnFcn</name>
      <anchor>MnFcna0</anchor>
      <arglist>(const FCNBase &amp;fcn)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~MnFcn</name>
      <anchor>MnFcna1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual double</type>
      <name>operator()</name>
      <anchor>MnFcna2</anchor>
      <arglist>(const MnAlgebraicVector &amp;) const </arglist>
    </member>
    <member kind="function">
      <type>unsigned int</type>
      <name>numOfCalls</name>
      <anchor>MnUserFcna3</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>errorDef</name>
      <anchor>MnUserFcna4</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>up</name>
      <anchor>MnUserFcna5</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const FCNBase &amp;</type>
      <name>fcn</name>
      <anchor>MnUserFcna6</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>int</type>
      <name>theNumCall</name>
      <anchor>MnUserFcnp0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>const FCNBase &amp;</type>
      <name>theFCN</name>
      <anchor>MnFcnr0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>MnFunctionCross</name>
    <filename>classMnFunctionCross.html</filename>
    <member kind="function">
      <type></type>
      <name>MnFunctionCross</name>
      <anchor>MnFunctionCrossa0</anchor>
      <arglist>(const FCNBase &amp;fcn, const MnUserParameterState &amp;state, double fval, const MnStrategy &amp;stra)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~MnFunctionCross</name>
      <anchor>MnFunctionCrossa1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>MnCross</type>
      <name>operator()</name>
      <anchor>MnFunctionCrossa2</anchor>
      <arglist>(const std::vector&lt; unsigned int &gt; &amp;, const std::vector&lt; double &gt; &amp;, const std::vector&lt; double &gt; &amp;, double, unsigned int) const </arglist>
    </member>
    <member kind="variable" protection="private">
      <type>const FCNBase &amp;</type>
      <name>theFCN</name>
      <anchor>MnFunctionCrossr0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>const MnUserParameterState &amp;</type>
      <name>theState</name>
      <anchor>MnFunctionCrossr1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theFval</name>
      <anchor>MnFunctionCrossr2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>const MnStrategy &amp;</type>
      <name>theStrategy</name>
      <anchor>MnFunctionCrossr3</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>MnGlobalCorrelationCoeff</name>
    <filename>classMnGlobalCorrelationCoeff.html</filename>
    <member kind="function">
      <type></type>
      <name>MnGlobalCorrelationCoeff</name>
      <anchor>MnGlobalCorrelationCoeffa0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>MnGlobalCorrelationCoeff</name>
      <anchor>MnGlobalCorrelationCoeffa1</anchor>
      <arglist>(const MnAlgebraicSymMatrix &amp;)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~MnGlobalCorrelationCoeff</name>
      <anchor>MnGlobalCorrelationCoeffa2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>const std::vector&lt; double &gt; &amp;</type>
      <name>globalCC</name>
      <anchor>MnGlobalCorrelationCoeffa3</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>isValid</name>
      <anchor>MnGlobalCorrelationCoeffa4</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="variable" protection="private">
      <type>std::vector&lt; double &gt;</type>
      <name>theGlobalCC</name>
      <anchor>MnGlobalCorrelationCoeffr0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool</type>
      <name>theValid</name>
      <anchor>MnGlobalCorrelationCoeffr1</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>MnHesse</name>
    <filename>classMnHesse.html</filename>
    <member kind="function">
      <type></type>
      <name>MnHesse</name>
      <anchor>MnHessea0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>MnHesse</name>
      <anchor>MnHessea1</anchor>
      <arglist>(unsigned int stra)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>MnHesse</name>
      <anchor>MnHessea2</anchor>
      <arglist>(const MnStrategy &amp;stra)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~MnHesse</name>
      <anchor>MnHessea3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>MnUserParameterState</type>
      <name>operator()</name>
      <anchor>MnHessea4</anchor>
      <arglist>(const FCNBase &amp;, const std::vector&lt; double &gt; &amp;, const std::vector&lt; double &gt; &amp;, unsigned int maxcalls=0) const </arglist>
    </member>
    <member kind="function">
      <type>MnUserParameterState</type>
      <name>operator()</name>
      <anchor>MnHessea5</anchor>
      <arglist>(const FCNBase &amp;, const std::vector&lt; double &gt; &amp;, const std::vector&lt; double &gt; &amp;, unsigned int, unsigned int maxcalls=0) const </arglist>
    </member>
    <member kind="function">
      <type>MnUserParameterState</type>
      <name>operator()</name>
      <anchor>MnHessea6</anchor>
      <arglist>(const FCNBase &amp;, const std::vector&lt; double &gt; &amp;, const MnUserCovariance &amp;, unsigned int maxcalls=0) const </arglist>
    </member>
    <member kind="function">
      <type>MnUserParameterState</type>
      <name>operator()</name>
      <anchor>MnHessea7</anchor>
      <arglist>(const FCNBase &amp;, const MnUserParameters &amp;, unsigned int maxcalls=0) const </arglist>
    </member>
    <member kind="function">
      <type>MnUserParameterState</type>
      <name>operator()</name>
      <anchor>MnHessea8</anchor>
      <arglist>(const FCNBase &amp;, const MnUserParameters &amp;, const MnUserCovariance &amp;, unsigned int maxcalls=0) const </arglist>
    </member>
    <member kind="function">
      <type>MnUserParameterState</type>
      <name>operator()</name>
      <anchor>MnHessea9</anchor>
      <arglist>(const FCNBase &amp;, const MnUserParameterState &amp;, unsigned int maxcalls=0) const </arglist>
    </member>
    <member kind="function">
      <type>MinimumState</type>
      <name>operator()</name>
      <anchor>MnHessea10</anchor>
      <arglist>(const MnFcn &amp;, const MinimumState &amp;, const MnUserTransformation &amp;, unsigned int maxcalls=0) const </arglist>
    </member>
    <member kind="function">
      <type>unsigned int</type>
      <name>ncycles</name>
      <anchor>MnHessea11</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>tolerstp</name>
      <anchor>MnHessea12</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>tolerg2</name>
      <anchor>MnHessea13</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="variable" protection="private">
      <type>MnStrategy</type>
      <name>theStrategy</name>
      <anchor>MnHesser0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>MnLineSearch</name>
    <filename>classMnLineSearch.html</filename>
    <member kind="function">
      <type></type>
      <name>MnLineSearch</name>
      <anchor>MnLineSearcha0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~MnLineSearch</name>
      <anchor>MnLineSearcha1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>MnParabolaPoint</type>
      <name>operator()</name>
      <anchor>MnLineSearcha2</anchor>
      <arglist>(const MnFcn &amp;, const MinimumParameters &amp;, const MnAlgebraicVector &amp;, double, const MnMachinePrecision &amp;) const </arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>MnMachinePrecision</name>
    <filename>classMnMachinePrecision.html</filename>
    <member kind="function">
      <type></type>
      <name>MnMachinePrecision</name>
      <anchor>MnMachinePrecisiona0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~MnMachinePrecision</name>
      <anchor>MnMachinePrecisiona1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>MnMachinePrecision</name>
      <anchor>MnMachinePrecisiona2</anchor>
      <arglist>(const MnMachinePrecision &amp;prec)</arglist>
    </member>
    <member kind="function">
      <type>MnMachinePrecision &amp;</type>
      <name>operator=</name>
      <anchor>MnMachinePrecisiona3</anchor>
      <arglist>(const MnMachinePrecision &amp;prec)</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>eps</name>
      <anchor>MnMachinePrecisiona4</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>eps2</name>
      <anchor>MnMachinePrecisiona5</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setPrecision</name>
      <anchor>MnMachinePrecisiona6</anchor>
      <arglist>(double prec)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theEpsMac</name>
      <anchor>MnMachinePrecisionr0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theEpsMa2</name>
      <anchor>MnMachinePrecisionr1</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>MnMigrad</name>
    <filename>classMnMigrad.html</filename>
    <base>MnApplication</base>
    <member kind="function">
      <type></type>
      <name>MnMigrad</name>
      <anchor>MnMigrada0</anchor>
      <arglist>(const FCNBase &amp;fcn, const std::vector&lt; double &gt; &amp;par, const std::vector&lt; double &gt; &amp;err, unsigned int stra=1)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>MnMigrad</name>
      <anchor>MnMigrada1</anchor>
      <arglist>(const FCNBase &amp;fcn, const std::vector&lt; double &gt; &amp;par, const std::vector&lt; double &gt; &amp;cov, unsigned int nrow, unsigned int stra=1)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>MnMigrad</name>
      <anchor>MnMigrada2</anchor>
      <arglist>(const FCNBase &amp;fcn, const std::vector&lt; double &gt; &amp;par, const MnUserCovariance &amp;cov, unsigned int stra=1)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>MnMigrad</name>
      <anchor>MnMigrada3</anchor>
      <arglist>(const FCNBase &amp;fcn, const MnUserParameters &amp;par, unsigned int stra=1)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>MnMigrad</name>
      <anchor>MnMigrada4</anchor>
      <arglist>(const FCNBase &amp;fcn, const MnUserParameters &amp;par, const MnUserCovariance &amp;cov, unsigned int stra=1)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>MnMigrad</name>
      <anchor>MnMigrada5</anchor>
      <arglist>(const FCNBase &amp;fcn, const MnUserParameterState &amp;par, const MnStrategy &amp;str)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>MnMigrad</name>
      <anchor>MnMigrada6</anchor>
      <arglist>(const MnMigrad &amp;migr)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~MnMigrad</name>
      <anchor>MnMigrada7</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>const ModularFunctionMinimizer &amp;</type>
      <name>minimizer</name>
      <anchor>MnMigrada8</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual FunctionMinimum</type>
      <name>operator()</name>
      <anchor>MnSimplexa9</anchor>
      <arglist>(unsigned int=0, double=0.1)</arglist>
    </member>
    <member kind="function">
      <type>const MnMachinePrecision &amp;</type>
      <name>precision</name>
      <anchor>MnSimplexa10</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const MnUserParameterState &amp;</type>
      <name>state</name>
      <anchor>MnSimplexa11</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const MnUserParameters &amp;</type>
      <name>parameters</name>
      <anchor>MnSimplexa12</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const MnUserCovariance &amp;</type>
      <name>covariance</name>
      <anchor>MnSimplexa13</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const FCNBase &amp;</type>
      <name>fcnbase</name>
      <anchor>MnSimplexa14</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const MnStrategy &amp;</type>
      <name>strategy</name>
      <anchor>MnSimplexa15</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>unsigned int</type>
      <name>numOfCalls</name>
      <anchor>MnSimplexa16</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const std::vector&lt; MinuitParameter &gt; &amp;</type>
      <name>minuitParameters</name>
      <anchor>MnSimplexa17</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>std::vector&lt; double &gt;</type>
      <name>params</name>
      <anchor>MnSimplexa18</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>std::vector&lt; double &gt;</type>
      <name>errors</name>
      <anchor>MnSimplexa19</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const MinuitParameter &amp;</type>
      <name>parameter</name>
      <anchor>MnSimplexa20</anchor>
      <arglist>(unsigned int i) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>add</name>
      <anchor>MnSimplexa21</anchor>
      <arglist>(const char *name, double val, double err)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>add</name>
      <anchor>MnSimplexa22</anchor>
      <arglist>(const char *name, double val, double err, double, double)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>add</name>
      <anchor>MnSimplexa23</anchor>
      <arglist>(const char *, double)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>fix</name>
      <anchor>MnSimplexa24</anchor>
      <arglist>(unsigned int)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>fix</name>
      <anchor>MnSimplexa25</anchor>
      <arglist>(const char *)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>release</name>
      <anchor>MnSimplexa26</anchor>
      <arglist>(unsigned int)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>release</name>
      <anchor>MnSimplexa27</anchor>
      <arglist>(const char *)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setValue</name>
      <anchor>MnSimplexa28</anchor>
      <arglist>(unsigned int, double)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setValue</name>
      <anchor>MnSimplexa29</anchor>
      <arglist>(const char *, double)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setError</name>
      <anchor>MnSimplexa30</anchor>
      <arglist>(unsigned int, double)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setError</name>
      <anchor>MnSimplexa31</anchor>
      <arglist>(const char *, double)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setLimits</name>
      <anchor>MnSimplexa32</anchor>
      <arglist>(unsigned int, double, double)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setLimits</name>
      <anchor>MnSimplexa33</anchor>
      <arglist>(const char *, double, double)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>removeLimits</name>
      <anchor>MnSimplexa34</anchor>
      <arglist>(unsigned int)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>removeLimits</name>
      <anchor>MnSimplexa35</anchor>
      <arglist>(const char *)</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>value</name>
      <anchor>MnSimplexa36</anchor>
      <arglist>(unsigned int) const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>value</name>
      <anchor>MnSimplexa37</anchor>
      <arglist>(const char *) const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>error</name>
      <anchor>MnSimplexa38</anchor>
      <arglist>(unsigned int) const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>error</name>
      <anchor>MnSimplexa39</anchor>
      <arglist>(const char *) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setPrecision</name>
      <anchor>MnSimplexa40</anchor>
      <arglist>(double)</arglist>
    </member>
    <member kind="function">
      <type>unsigned int</type>
      <name>index</name>
      <anchor>MnSimplexa41</anchor>
      <arglist>(const char *) const </arglist>
    </member>
    <member kind="function">
      <type>const char *</type>
      <name>name</name>
      <anchor>MnSimplexa42</anchor>
      <arglist>(unsigned int) const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>int2ext</name>
      <anchor>MnSimplexa43</anchor>
      <arglist>(unsigned int, double) const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>ext2int</name>
      <anchor>MnSimplexa44</anchor>
      <arglist>(unsigned int, double) const </arglist>
    </member>
    <member kind="function">
      <type>unsigned int</type>
      <name>intOfExt</name>
      <anchor>MnSimplexa45</anchor>
      <arglist>(unsigned int) const </arglist>
    </member>
    <member kind="function">
      <type>unsigned int</type>
      <name>extOfInt</name>
      <anchor>MnSimplexa46</anchor>
      <arglist>(unsigned int) const </arglist>
    </member>
    <member kind="function">
      <type>unsigned int</type>
      <name>variableParameters</name>
      <anchor>MnSimplexa47</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>const FCNBase &amp;</type>
      <name>theFCN</name>
      <anchor>MnSimplexp0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>MnUserParameterState</type>
      <name>theState</name>
      <anchor>MnSimplexp1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>MnStrategy</type>
      <name>theStrategy</name>
      <anchor>MnSimplexp2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>unsigned int</type>
      <name>theNumCall</name>
      <anchor>MnSimplexp3</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" protection="private">
      <type>MnMigrad &amp;</type>
      <name>operator=</name>
      <anchor>MnMigradd0</anchor>
      <arglist>(const MnMigrad &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>VariableMetricMinimizer</type>
      <name>theMinimizer</name>
      <anchor>MnMigradr0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>MnMinimize</name>
    <filename>classMnMinimize.html</filename>
    <base>MnApplication</base>
    <member kind="function">
      <type></type>
      <name>MnMinimize</name>
      <anchor>MnMinimizea0</anchor>
      <arglist>(const FCNBase &amp;fcn, const std::vector&lt; double &gt; &amp;par, const std::vector&lt; double &gt; &amp;err, unsigned int stra=1)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>MnMinimize</name>
      <anchor>MnMinimizea1</anchor>
      <arglist>(const FCNBase &amp;fcn, const std::vector&lt; double &gt; &amp;par, const std::vector&lt; double &gt; &amp;cov, unsigned int nrow, unsigned int stra=1)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>MnMinimize</name>
      <anchor>MnMinimizea2</anchor>
      <arglist>(const FCNBase &amp;fcn, const std::vector&lt; double &gt; &amp;par, const MnUserCovariance &amp;cov, unsigned int stra=1)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>MnMinimize</name>
      <anchor>MnMinimizea3</anchor>
      <arglist>(const FCNBase &amp;fcn, const MnUserParameters &amp;par, unsigned int stra=1)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>MnMinimize</name>
      <anchor>MnMinimizea4</anchor>
      <arglist>(const FCNBase &amp;fcn, const MnUserParameters &amp;par, const MnUserCovariance &amp;cov, unsigned int stra=1)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>MnMinimize</name>
      <anchor>MnMinimizea5</anchor>
      <arglist>(const FCNBase &amp;fcn, const MnUserParameterState &amp;par, const MnStrategy &amp;str)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>MnMinimize</name>
      <anchor>MnMinimizea6</anchor>
      <arglist>(const MnMinimize &amp;migr)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~MnMinimize</name>
      <anchor>MnMinimizea7</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>const ModularFunctionMinimizer &amp;</type>
      <name>minimizer</name>
      <anchor>MnMinimizea8</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual FunctionMinimum</type>
      <name>operator()</name>
      <anchor>MnSimplexa9</anchor>
      <arglist>(unsigned int=0, double=0.1)</arglist>
    </member>
    <member kind="function">
      <type>const MnMachinePrecision &amp;</type>
      <name>precision</name>
      <anchor>MnSimplexa10</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const MnUserParameterState &amp;</type>
      <name>state</name>
      <anchor>MnSimplexa11</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const MnUserParameters &amp;</type>
      <name>parameters</name>
      <anchor>MnSimplexa12</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const MnUserCovariance &amp;</type>
      <name>covariance</name>
      <anchor>MnSimplexa13</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const FCNBase &amp;</type>
      <name>fcnbase</name>
      <anchor>MnSimplexa14</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const MnStrategy &amp;</type>
      <name>strategy</name>
      <anchor>MnSimplexa15</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>unsigned int</type>
      <name>numOfCalls</name>
      <anchor>MnSimplexa16</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const std::vector&lt; MinuitParameter &gt; &amp;</type>
      <name>minuitParameters</name>
      <anchor>MnSimplexa17</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>std::vector&lt; double &gt;</type>
      <name>params</name>
      <anchor>MnSimplexa18</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>std::vector&lt; double &gt;</type>
      <name>errors</name>
      <anchor>MnSimplexa19</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const MinuitParameter &amp;</type>
      <name>parameter</name>
      <anchor>MnSimplexa20</anchor>
      <arglist>(unsigned int i) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>add</name>
      <anchor>MnSimplexa21</anchor>
      <arglist>(const char *name, double val, double err)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>add</name>
      <anchor>MnSimplexa22</anchor>
      <arglist>(const char *name, double val, double err, double, double)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>add</name>
      <anchor>MnSimplexa23</anchor>
      <arglist>(const char *, double)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>fix</name>
      <anchor>MnSimplexa24</anchor>
      <arglist>(unsigned int)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>fix</name>
      <anchor>MnSimplexa25</anchor>
      <arglist>(const char *)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>release</name>
      <anchor>MnSimplexa26</anchor>
      <arglist>(unsigned int)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>release</name>
      <anchor>MnSimplexa27</anchor>
      <arglist>(const char *)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setValue</name>
      <anchor>MnSimplexa28</anchor>
      <arglist>(unsigned int, double)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setValue</name>
      <anchor>MnSimplexa29</anchor>
      <arglist>(const char *, double)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setError</name>
      <anchor>MnSimplexa30</anchor>
      <arglist>(unsigned int, double)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setError</name>
      <anchor>MnSimplexa31</anchor>
      <arglist>(const char *, double)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setLimits</name>
      <anchor>MnSimplexa32</anchor>
      <arglist>(unsigned int, double, double)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setLimits</name>
      <anchor>MnSimplexa33</anchor>
      <arglist>(const char *, double, double)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>removeLimits</name>
      <anchor>MnSimplexa34</anchor>
      <arglist>(unsigned int)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>removeLimits</name>
      <anchor>MnSimplexa35</anchor>
      <arglist>(const char *)</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>value</name>
      <anchor>MnSimplexa36</anchor>
      <arglist>(unsigned int) const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>value</name>
      <anchor>MnSimplexa37</anchor>
      <arglist>(const char *) const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>error</name>
      <anchor>MnSimplexa38</anchor>
      <arglist>(unsigned int) const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>error</name>
      <anchor>MnSimplexa39</anchor>
      <arglist>(const char *) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setPrecision</name>
      <anchor>MnSimplexa40</anchor>
      <arglist>(double)</arglist>
    </member>
    <member kind="function">
      <type>unsigned int</type>
      <name>index</name>
      <anchor>MnSimplexa41</anchor>
      <arglist>(const char *) const </arglist>
    </member>
    <member kind="function">
      <type>const char *</type>
      <name>name</name>
      <anchor>MnSimplexa42</anchor>
      <arglist>(unsigned int) const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>int2ext</name>
      <anchor>MnSimplexa43</anchor>
      <arglist>(unsigned int, double) const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>ext2int</name>
      <anchor>MnSimplexa44</anchor>
      <arglist>(unsigned int, double) const </arglist>
    </member>
    <member kind="function">
      <type>unsigned int</type>
      <name>intOfExt</name>
      <anchor>MnSimplexa45</anchor>
      <arglist>(unsigned int) const </arglist>
    </member>
    <member kind="function">
      <type>unsigned int</type>
      <name>extOfInt</name>
      <anchor>MnSimplexa46</anchor>
      <arglist>(unsigned int) const </arglist>
    </member>
    <member kind="function">
      <type>unsigned int</type>
      <name>variableParameters</name>
      <anchor>MnSimplexa47</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>const FCNBase &amp;</type>
      <name>theFCN</name>
      <anchor>MnSimplexp0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>MnUserParameterState</type>
      <name>theState</name>
      <anchor>MnSimplexp1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>MnStrategy</type>
      <name>theStrategy</name>
      <anchor>MnSimplexp2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>unsigned int</type>
      <name>theNumCall</name>
      <anchor>MnSimplexp3</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" protection="private">
      <type>MnMinimize &amp;</type>
      <name>operator=</name>
      <anchor>MnMinimized0</anchor>
      <arglist>(const MnMinimize &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>CombinedMinimizer</type>
      <name>theMinimizer</name>
      <anchor>MnMinimizer0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>MnMinos</name>
    <filename>classMnMinos.html</filename>
    <member kind="function">
      <type></type>
      <name>MnMinos</name>
      <anchor>MnMinosa0</anchor>
      <arglist>(const FCNBase &amp;fcn, const FunctionMinimum &amp;min)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>MnMinos</name>
      <anchor>MnMinosa1</anchor>
      <arglist>(const FCNBase &amp;fcn, const FunctionMinimum &amp;min, unsigned int stra)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>MnMinos</name>
      <anchor>MnMinosa2</anchor>
      <arglist>(const FCNBase &amp;fcn, const FunctionMinimum &amp;min, const MnStrategy &amp;stra)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~MnMinos</name>
      <anchor>MnMinosa3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>std::pair&lt; double, double &gt;</type>
      <name>operator()</name>
      <anchor>MnMinosa4</anchor>
      <arglist>(unsigned int, unsigned int maxcalls=0) const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>lower</name>
      <anchor>MnMinosa5</anchor>
      <arglist>(unsigned int, unsigned int maxcalls=0) const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>upper</name>
      <anchor>MnMinosa6</anchor>
      <arglist>(unsigned int, unsigned int maxcalls=0) const </arglist>
    </member>
    <member kind="function">
      <type>MnCross</type>
      <name>loval</name>
      <anchor>MnMinosa7</anchor>
      <arglist>(unsigned int, unsigned int maxcalls=0) const </arglist>
    </member>
    <member kind="function">
      <type>MnCross</type>
      <name>upval</name>
      <anchor>MnMinosa8</anchor>
      <arglist>(unsigned int, unsigned int maxcalls=0) const </arglist>
    </member>
    <member kind="function">
      <type>MinosError</type>
      <name>minos</name>
      <anchor>MnMinosa9</anchor>
      <arglist>(unsigned int, unsigned int maxcalls=0) const </arglist>
    </member>
    <member kind="variable" protection="private">
      <type>const FCNBase &amp;</type>
      <name>theFCN</name>
      <anchor>MnMinosr0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>const FunctionMinimum &amp;</type>
      <name>theMinimum</name>
      <anchor>MnMinosr1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>MnStrategy</type>
      <name>theStrategy</name>
      <anchor>MnMinosr2</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>MnParabola</name>
    <filename>classMnParabola.html</filename>
    <member kind="function">
      <type></type>
      <name>MnParabola</name>
      <anchor>MnParabolaa0</anchor>
      <arglist>(double a, double b, double c)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~MnParabola</name>
      <anchor>MnParabolaa1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>y</name>
      <anchor>MnParabolaa2</anchor>
      <arglist>(double x) const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>x_pos</name>
      <anchor>MnParabolaa3</anchor>
      <arglist>(double y) const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>x_neg</name>
      <anchor>MnParabolaa4</anchor>
      <arglist>(double y) const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>min</name>
      <anchor>MnParabolaa5</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>ymin</name>
      <anchor>MnParabolaa6</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>a</name>
      <anchor>MnParabolaa7</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>b</name>
      <anchor>MnParabolaa8</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>c</name>
      <anchor>MnParabolaa9</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theA</name>
      <anchor>MnParabolar0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theB</name>
      <anchor>MnParabolar1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theC</name>
      <anchor>MnParabolar2</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>MnParabolaFactory</name>
    <filename>classMnParabolaFactory.html</filename>
    <member kind="function">
      <type></type>
      <name>MnParabolaFactory</name>
      <anchor>MnParabolaFactorya0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~MnParabolaFactory</name>
      <anchor>MnParabolaFactorya1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>MnParabola</type>
      <name>operator()</name>
      <anchor>MnParabolaFactorya2</anchor>
      <arglist>(const MnParabolaPoint &amp;, const MnParabolaPoint &amp;, const MnParabolaPoint &amp;) const </arglist>
    </member>
    <member kind="function">
      <type>MnParabola</type>
      <name>operator()</name>
      <anchor>MnParabolaFactorya3</anchor>
      <arglist>(const MnParabolaPoint &amp;, double, const MnParabolaPoint &amp;) const </arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>MnParabolaPoint</name>
    <filename>classMnParabolaPoint.html</filename>
    <member kind="function">
      <type></type>
      <name>MnParabolaPoint</name>
      <anchor>MnParabolaPointa0</anchor>
      <arglist>(double x, double y)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~MnParabolaPoint</name>
      <anchor>MnParabolaPointa1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>x</name>
      <anchor>MnParabolaPointa2</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>y</name>
      <anchor>MnParabolaPointa3</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theX</name>
      <anchor>MnParabolaPointr0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theY</name>
      <anchor>MnParabolaPointr1</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>MnParameterScan</name>
    <filename>classMnParameterScan.html</filename>
    <member kind="function">
      <type></type>
      <name>MnParameterScan</name>
      <anchor>MnParameterScana0</anchor>
      <arglist>(const FCNBase &amp;, const MnUserParameters &amp;)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>MnParameterScan</name>
      <anchor>MnParameterScana1</anchor>
      <arglist>(const FCNBase &amp;, const MnUserParameters &amp;, double)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~MnParameterScan</name>
      <anchor>MnParameterScana2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>std::vector&lt; std::pair&lt; double, double &gt; &gt;</type>
      <name>operator()</name>
      <anchor>MnParameterScana3</anchor>
      <arglist>(unsigned int par, unsigned int maxsteps=41, double low=0., double high=0.)</arglist>
    </member>
    <member kind="function">
      <type>const MnUserParameters &amp;</type>
      <name>parameters</name>
      <anchor>MnParameterScana4</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>fval</name>
      <anchor>MnParameterScana5</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="variable" protection="private">
      <type>const FCNBase &amp;</type>
      <name>theFCN</name>
      <anchor>MnParameterScanr0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>MnUserParameters</type>
      <name>theParameters</name>
      <anchor>MnParameterScanr1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theAmin</name>
      <anchor>MnParameterScanr2</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>MnParStr</name>
    <filename>classMnParStr.html</filename>
    <member kind="function">
      <type></type>
      <name>MnParStr</name>
      <anchor>MnParStra0</anchor>
      <arglist>(const char *name)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~MnParStr</name>
      <anchor>MnParStra1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator()</name>
      <anchor>MnParStra2</anchor>
      <arglist>(const MinuitParameter &amp;par) const </arglist>
    </member>
    <member kind="variable" protection="private">
      <type>const char *</type>
      <name>theName</name>
      <anchor>MnParStrr0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>MnPlot</name>
    <filename>classMnPlot.html</filename>
    <member kind="function">
      <type></type>
      <name>MnPlot</name>
      <anchor>MnPlota0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>MnPlot</name>
      <anchor>MnPlota1</anchor>
      <arglist>(unsigned int width, unsigned int length)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~MnPlot</name>
      <anchor>MnPlota2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>operator()</name>
      <anchor>MnPlota3</anchor>
      <arglist>(const std::vector&lt; std::pair&lt; double, double &gt; &gt; &amp;) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>operator()</name>
      <anchor>MnPlota4</anchor>
      <arglist>(double, double, const std::vector&lt; std::pair&lt; double, double &gt; &gt; &amp;) const </arglist>
    </member>
    <member kind="function">
      <type>unsigned int</type>
      <name>width</name>
      <anchor>MnPlota5</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>unsigned int</type>
      <name>length</name>
      <anchor>MnPlota6</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="variable" protection="private">
      <type>unsigned int</type>
      <name>thePageWidth</name>
      <anchor>MnPlotr0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>unsigned int</type>
      <name>thePageLength</name>
      <anchor>MnPlotr1</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>MnPosDef</name>
    <filename>classMnPosDef.html</filename>
    <member kind="function">
      <type></type>
      <name>MnPosDef</name>
      <anchor>MnPosDefa0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~MnPosDef</name>
      <anchor>MnPosDefa1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>MinimumState</type>
      <name>operator()</name>
      <anchor>MnPosDefa2</anchor>
      <arglist>(const MinimumState &amp;, const MnMachinePrecision &amp;) const </arglist>
    </member>
    <member kind="function">
      <type>MinimumError</type>
      <name>operator()</name>
      <anchor>MnPosDefa3</anchor>
      <arglist>(const MinimumError &amp;, const MnMachinePrecision &amp;) const </arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>MnRefCountedPointer</name>
    <filename>classMnRefCountedPointer.html</filename>
    <templarg>T</templarg>
    <member kind="function">
      <type></type>
      <name>MnRefCountedPointer</name>
      <anchor>MnRefCountedPointera0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>MnRefCountedPointer</name>
      <anchor>MnRefCountedPointera1</anchor>
      <arglist>(T *pt)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>MnRefCountedPointer</name>
      <anchor>MnRefCountedPointera2</anchor>
      <arglist>(const MnRefCountedPointer&lt; T &gt; &amp;other)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~MnRefCountedPointer</name>
      <anchor>MnRefCountedPointera3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>isValid</name>
      <anchor>MnRefCountedPointera4</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>MnRefCountedPointer &amp;</type>
      <name>operator=</name>
      <anchor>MnRefCountedPointera5</anchor>
      <arglist>(const MnRefCountedPointer&lt; T &gt; &amp;other)</arglist>
    </member>
    <member kind="function">
      <type>MnRefCountedPointer &amp;</type>
      <name>operator=</name>
      <anchor>MnRefCountedPointera6</anchor>
      <arglist>(T *ptr)</arglist>
    </member>
    <member kind="function">
      <type>T *</type>
      <name>get</name>
      <anchor>MnRefCountedPointera7</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>T *</type>
      <name>operator-&gt;</name>
      <anchor>MnRefCountedPointera8</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>T &amp;</type>
      <name>operator *</name>
      <anchor>MnRefCountedPointera9</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator==</name>
      <anchor>MnRefCountedPointera10</anchor>
      <arglist>(const T *otherP) const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator&lt;</name>
      <anchor>MnRefCountedPointera11</anchor>
      <arglist>(const T *otherP) const </arglist>
    </member>
    <member kind="function">
      <type>unsigned int</type>
      <name>references</name>
      <anchor>MnRefCountedPointera12</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>addReference</name>
      <anchor>MnRefCountedPointera13</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>removeReference</name>
      <anchor>MnRefCountedPointera14</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>check</name>
      <anchor>MnRefCountedPointerd0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="variable" protection="private">
      <type>T *</type>
      <name>thePtr</name>
      <anchor>MnRefCountedPointerr0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>MnReferenceCounter *</type>
      <name>theCounter</name>
      <anchor>MnRefCountedPointerr1</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>MnReferenceCounter</name>
    <filename>classMnReferenceCounter.html</filename>
    <member kind="function">
      <type></type>
      <name>MnReferenceCounter</name>
      <anchor>MnReferenceCountera0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>MnReferenceCounter</name>
      <anchor>MnReferenceCountera1</anchor>
      <arglist>(const MnReferenceCounter &amp;other)</arglist>
    </member>
    <member kind="function">
      <type>MnReferenceCounter &amp;</type>
      <name>operator=</name>
      <anchor>MnReferenceCountera2</anchor>
      <arglist>(const MnReferenceCounter &amp;other)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~MnReferenceCounter</name>
      <anchor>MnReferenceCountera3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void *</type>
      <name>operator new</name>
      <anchor>MnReferenceCountera4</anchor>
      <arglist>(size_t nbytes)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>operator delete</name>
      <anchor>MnReferenceCountera5</anchor>
      <arglist>(void *p, size_t)</arglist>
    </member>
    <member kind="function">
      <type>unsigned int</type>
      <name>references</name>
      <anchor>MnReferenceCountera6</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>addReference</name>
      <anchor>MnReferenceCountera7</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>removeReference</name>
      <anchor>MnReferenceCountera8</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="variable" protection="private">
      <type>unsigned int</type>
      <name>theReferences</name>
      <anchor>MnReferenceCounterr0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>MnScan</name>
    <filename>classMnScan.html</filename>
    <base>MnApplication</base>
    <member kind="function">
      <type></type>
      <name>MnScan</name>
      <anchor>MnScana0</anchor>
      <arglist>(const FCNBase &amp;fcn, const std::vector&lt; double &gt; &amp;par, const std::vector&lt; double &gt; &amp;err, unsigned int stra=1)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>MnScan</name>
      <anchor>MnScana1</anchor>
      <arglist>(const FCNBase &amp;fcn, const std::vector&lt; double &gt; &amp;par, const std::vector&lt; double &gt; &amp;cov, unsigned int nrow, unsigned int stra=1)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>MnScan</name>
      <anchor>MnScana2</anchor>
      <arglist>(const FCNBase &amp;fcn, const std::vector&lt; double &gt; &amp;par, const MnUserCovariance &amp;cov, unsigned int stra=1)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>MnScan</name>
      <anchor>MnScana3</anchor>
      <arglist>(const FCNBase &amp;fcn, const MnUserParameters &amp;par, unsigned int stra=1)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>MnScan</name>
      <anchor>MnScana4</anchor>
      <arglist>(const FCNBase &amp;fcn, const MnUserParameters &amp;par, const MnUserCovariance &amp;cov, unsigned int stra=1)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>MnScan</name>
      <anchor>MnScana5</anchor>
      <arglist>(const FCNBase &amp;fcn, const MnUserParameterState &amp;par, const MnStrategy &amp;str)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>MnScan</name>
      <anchor>MnScana6</anchor>
      <arglist>(const MnScan &amp;migr)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~MnScan</name>
      <anchor>MnScana7</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>const ModularFunctionMinimizer &amp;</type>
      <name>minimizer</name>
      <anchor>MnScana8</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>std::vector&lt; std::pair&lt; double, double &gt; &gt;</type>
      <name>scan</name>
      <anchor>MnScana9</anchor>
      <arglist>(unsigned int par, unsigned int maxsteps=41, double low=0., double high=0.)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual FunctionMinimum</type>
      <name>operator()</name>
      <anchor>MnSimplexa9</anchor>
      <arglist>(unsigned int=0, double=0.1)</arglist>
    </member>
    <member kind="function">
      <type>const MnMachinePrecision &amp;</type>
      <name>precision</name>
      <anchor>MnSimplexa10</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const MnUserParameterState &amp;</type>
      <name>state</name>
      <anchor>MnSimplexa11</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const MnUserParameters &amp;</type>
      <name>parameters</name>
      <anchor>MnSimplexa12</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const MnUserCovariance &amp;</type>
      <name>covariance</name>
      <anchor>MnSimplexa13</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const FCNBase &amp;</type>
      <name>fcnbase</name>
      <anchor>MnSimplexa14</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const MnStrategy &amp;</type>
      <name>strategy</name>
      <anchor>MnSimplexa15</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>unsigned int</type>
      <name>numOfCalls</name>
      <anchor>MnSimplexa16</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const std::vector&lt; MinuitParameter &gt; &amp;</type>
      <name>minuitParameters</name>
      <anchor>MnSimplexa17</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>std::vector&lt; double &gt;</type>
      <name>params</name>
      <anchor>MnSimplexa18</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>std::vector&lt; double &gt;</type>
      <name>errors</name>
      <anchor>MnSimplexa19</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const MinuitParameter &amp;</type>
      <name>parameter</name>
      <anchor>MnSimplexa20</anchor>
      <arglist>(unsigned int i) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>add</name>
      <anchor>MnSimplexa21</anchor>
      <arglist>(const char *name, double val, double err)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>add</name>
      <anchor>MnSimplexa22</anchor>
      <arglist>(const char *name, double val, double err, double, double)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>add</name>
      <anchor>MnSimplexa23</anchor>
      <arglist>(const char *, double)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>fix</name>
      <anchor>MnSimplexa24</anchor>
      <arglist>(unsigned int)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>fix</name>
      <anchor>MnSimplexa25</anchor>
      <arglist>(const char *)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>release</name>
      <anchor>MnSimplexa26</anchor>
      <arglist>(unsigned int)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>release</name>
      <anchor>MnSimplexa27</anchor>
      <arglist>(const char *)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setValue</name>
      <anchor>MnSimplexa28</anchor>
      <arglist>(unsigned int, double)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setValue</name>
      <anchor>MnSimplexa29</anchor>
      <arglist>(const char *, double)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setError</name>
      <anchor>MnSimplexa30</anchor>
      <arglist>(unsigned int, double)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setError</name>
      <anchor>MnSimplexa31</anchor>
      <arglist>(const char *, double)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setLimits</name>
      <anchor>MnSimplexa32</anchor>
      <arglist>(unsigned int, double, double)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setLimits</name>
      <anchor>MnSimplexa33</anchor>
      <arglist>(const char *, double, double)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>removeLimits</name>
      <anchor>MnSimplexa34</anchor>
      <arglist>(unsigned int)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>removeLimits</name>
      <anchor>MnSimplexa35</anchor>
      <arglist>(const char *)</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>value</name>
      <anchor>MnSimplexa36</anchor>
      <arglist>(unsigned int) const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>value</name>
      <anchor>MnSimplexa37</anchor>
      <arglist>(const char *) const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>error</name>
      <anchor>MnSimplexa38</anchor>
      <arglist>(unsigned int) const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>error</name>
      <anchor>MnSimplexa39</anchor>
      <arglist>(const char *) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setPrecision</name>
      <anchor>MnSimplexa40</anchor>
      <arglist>(double)</arglist>
    </member>
    <member kind="function">
      <type>unsigned int</type>
      <name>index</name>
      <anchor>MnSimplexa41</anchor>
      <arglist>(const char *) const </arglist>
    </member>
    <member kind="function">
      <type>const char *</type>
      <name>name</name>
      <anchor>MnSimplexa42</anchor>
      <arglist>(unsigned int) const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>int2ext</name>
      <anchor>MnSimplexa43</anchor>
      <arglist>(unsigned int, double) const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>ext2int</name>
      <anchor>MnSimplexa44</anchor>
      <arglist>(unsigned int, double) const </arglist>
    </member>
    <member kind="function">
      <type>unsigned int</type>
      <name>intOfExt</name>
      <anchor>MnSimplexa45</anchor>
      <arglist>(unsigned int) const </arglist>
    </member>
    <member kind="function">
      <type>unsigned int</type>
      <name>extOfInt</name>
      <anchor>MnSimplexa46</anchor>
      <arglist>(unsigned int) const </arglist>
    </member>
    <member kind="function">
      <type>unsigned int</type>
      <name>variableParameters</name>
      <anchor>MnSimplexa47</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>const FCNBase &amp;</type>
      <name>theFCN</name>
      <anchor>MnSimplexp0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>MnUserParameterState</type>
      <name>theState</name>
      <anchor>MnSimplexp1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>MnStrategy</type>
      <name>theStrategy</name>
      <anchor>MnSimplexp2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>unsigned int</type>
      <name>theNumCall</name>
      <anchor>MnSimplexp3</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" protection="private">
      <type>MnScan &amp;</type>
      <name>operator=</name>
      <anchor>MnScand0</anchor>
      <arglist>(const MnScan &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ScanMinimizer</type>
      <name>theMinimizer</name>
      <anchor>MnScanr0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>MnSeedGenerator</name>
    <filename>classMnSeedGenerator.html</filename>
    <base>MinimumSeedGenerator</base>
    <member kind="function">
      <type></type>
      <name>MnSeedGenerator</name>
      <anchor>MnSeedGeneratora0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~MnSeedGenerator</name>
      <anchor>MnSeedGeneratora1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual MinimumSeed</type>
      <name>operator()</name>
      <anchor>MnSeedGeneratora2</anchor>
      <arglist>(const MnFcn &amp;, const GradientCalculator &amp;, const MnUserParameterState &amp;, const MnStrategy &amp;) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual MinimumSeed</type>
      <name>operator()</name>
      <anchor>MnSeedGeneratora3</anchor>
      <arglist>(const MnFcn &amp;, const AnalyticalGradientCalculator &amp;, const MnUserParameterState &amp;, const MnStrategy &amp;) const </arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>MnSimplex</name>
    <filename>classMnSimplex.html</filename>
    <base>MnApplication</base>
    <member kind="function">
      <type></type>
      <name>MnSimplex</name>
      <anchor>MnSimplexa0</anchor>
      <arglist>(const FCNBase &amp;fcn, const std::vector&lt; double &gt; &amp;par, const std::vector&lt; double &gt; &amp;err, unsigned int stra=1)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>MnSimplex</name>
      <anchor>MnSimplexa1</anchor>
      <arglist>(const FCNBase &amp;fcn, const std::vector&lt; double &gt; &amp;par, const std::vector&lt; double &gt; &amp;cov, unsigned int nrow, unsigned int stra=1)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>MnSimplex</name>
      <anchor>MnSimplexa2</anchor>
      <arglist>(const FCNBase &amp;fcn, const std::vector&lt; double &gt; &amp;par, const MnUserCovariance &amp;cov, unsigned int stra=1)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>MnSimplex</name>
      <anchor>MnSimplexa3</anchor>
      <arglist>(const FCNBase &amp;fcn, const MnUserParameters &amp;par, unsigned int stra=1)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>MnSimplex</name>
      <anchor>MnSimplexa4</anchor>
      <arglist>(const FCNBase &amp;fcn, const MnUserParameters &amp;par, const MnUserCovariance &amp;cov, unsigned int stra=1)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>MnSimplex</name>
      <anchor>MnSimplexa5</anchor>
      <arglist>(const FCNBase &amp;fcn, const MnUserParameterState &amp;par, const MnStrategy &amp;str)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>MnSimplex</name>
      <anchor>MnSimplexa6</anchor>
      <arglist>(const MnSimplex &amp;migr)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~MnSimplex</name>
      <anchor>MnSimplexa7</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>const ModularFunctionMinimizer &amp;</type>
      <name>minimizer</name>
      <anchor>MnSimplexa8</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual FunctionMinimum</type>
      <name>operator()</name>
      <anchor>MnSimplexa9</anchor>
      <arglist>(unsigned int=0, double=0.1)</arglist>
    </member>
    <member kind="function">
      <type>const MnMachinePrecision &amp;</type>
      <name>precision</name>
      <anchor>MnSimplexa10</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const MnUserParameterState &amp;</type>
      <name>state</name>
      <anchor>MnSimplexa11</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const MnUserParameters &amp;</type>
      <name>parameters</name>
      <anchor>MnSimplexa12</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const MnUserCovariance &amp;</type>
      <name>covariance</name>
      <anchor>MnSimplexa13</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const FCNBase &amp;</type>
      <name>fcnbase</name>
      <anchor>MnSimplexa14</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const MnStrategy &amp;</type>
      <name>strategy</name>
      <anchor>MnSimplexa15</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>unsigned int</type>
      <name>numOfCalls</name>
      <anchor>MnSimplexa16</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const std::vector&lt; MinuitParameter &gt; &amp;</type>
      <name>minuitParameters</name>
      <anchor>MnSimplexa17</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>std::vector&lt; double &gt;</type>
      <name>params</name>
      <anchor>MnSimplexa18</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>std::vector&lt; double &gt;</type>
      <name>errors</name>
      <anchor>MnSimplexa19</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const MinuitParameter &amp;</type>
      <name>parameter</name>
      <anchor>MnSimplexa20</anchor>
      <arglist>(unsigned int i) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>add</name>
      <anchor>MnSimplexa21</anchor>
      <arglist>(const char *name, double val, double err)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>add</name>
      <anchor>MnSimplexa22</anchor>
      <arglist>(const char *name, double val, double err, double, double)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>add</name>
      <anchor>MnSimplexa23</anchor>
      <arglist>(const char *, double)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>fix</name>
      <anchor>MnSimplexa24</anchor>
      <arglist>(unsigned int)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>fix</name>
      <anchor>MnSimplexa25</anchor>
      <arglist>(const char *)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>release</name>
      <anchor>MnSimplexa26</anchor>
      <arglist>(unsigned int)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>release</name>
      <anchor>MnSimplexa27</anchor>
      <arglist>(const char *)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setValue</name>
      <anchor>MnSimplexa28</anchor>
      <arglist>(unsigned int, double)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setValue</name>
      <anchor>MnSimplexa29</anchor>
      <arglist>(const char *, double)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setError</name>
      <anchor>MnSimplexa30</anchor>
      <arglist>(unsigned int, double)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setError</name>
      <anchor>MnSimplexa31</anchor>
      <arglist>(const char *, double)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setLimits</name>
      <anchor>MnSimplexa32</anchor>
      <arglist>(unsigned int, double, double)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setLimits</name>
      <anchor>MnSimplexa33</anchor>
      <arglist>(const char *, double, double)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>removeLimits</name>
      <anchor>MnSimplexa34</anchor>
      <arglist>(unsigned int)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>removeLimits</name>
      <anchor>MnSimplexa35</anchor>
      <arglist>(const char *)</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>value</name>
      <anchor>MnSimplexa36</anchor>
      <arglist>(unsigned int) const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>value</name>
      <anchor>MnSimplexa37</anchor>
      <arglist>(const char *) const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>error</name>
      <anchor>MnSimplexa38</anchor>
      <arglist>(unsigned int) const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>error</name>
      <anchor>MnSimplexa39</anchor>
      <arglist>(const char *) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setPrecision</name>
      <anchor>MnSimplexa40</anchor>
      <arglist>(double)</arglist>
    </member>
    <member kind="function">
      <type>unsigned int</type>
      <name>index</name>
      <anchor>MnSimplexa41</anchor>
      <arglist>(const char *) const </arglist>
    </member>
    <member kind="function">
      <type>const char *</type>
      <name>name</name>
      <anchor>MnSimplexa42</anchor>
      <arglist>(unsigned int) const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>int2ext</name>
      <anchor>MnSimplexa43</anchor>
      <arglist>(unsigned int, double) const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>ext2int</name>
      <anchor>MnSimplexa44</anchor>
      <arglist>(unsigned int, double) const </arglist>
    </member>
    <member kind="function">
      <type>unsigned int</type>
      <name>intOfExt</name>
      <anchor>MnSimplexa45</anchor>
      <arglist>(unsigned int) const </arglist>
    </member>
    <member kind="function">
      <type>unsigned int</type>
      <name>extOfInt</name>
      <anchor>MnSimplexa46</anchor>
      <arglist>(unsigned int) const </arglist>
    </member>
    <member kind="function">
      <type>unsigned int</type>
      <name>variableParameters</name>
      <anchor>MnSimplexa47</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>const FCNBase &amp;</type>
      <name>theFCN</name>
      <anchor>MnSimplexp0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>MnUserParameterState</type>
      <name>theState</name>
      <anchor>MnSimplexp1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>MnStrategy</type>
      <name>theStrategy</name>
      <anchor>MnSimplexp2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>unsigned int</type>
      <name>theNumCall</name>
      <anchor>MnSimplexp3</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" protection="private">
      <type>MnSimplex &amp;</type>
      <name>operator=</name>
      <anchor>MnSimplexd0</anchor>
      <arglist>(const MnSimplex &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>SimplexMinimizer</type>
      <name>theMinimizer</name>
      <anchor>MnSimplexr0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>MnStrategy</name>
    <filename>classMnStrategy.html</filename>
    <member kind="function">
      <type></type>
      <name>MnStrategy</name>
      <anchor>MnStrategya0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>MnStrategy</name>
      <anchor>MnStrategya1</anchor>
      <arglist>(unsigned int)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~MnStrategy</name>
      <anchor>MnStrategya2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>unsigned int</type>
      <name>strategy</name>
      <anchor>MnStrategya3</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>unsigned int</type>
      <name>gradientNCycles</name>
      <anchor>MnStrategya4</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>gradientStepTolerance</name>
      <anchor>MnStrategya5</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>gradientTolerance</name>
      <anchor>MnStrategya6</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>unsigned int</type>
      <name>hessianNCycles</name>
      <anchor>MnStrategya7</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>hessianStepTolerance</name>
      <anchor>MnStrategya8</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>hessianG2Tolerance</name>
      <anchor>MnStrategya9</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>unsigned int</type>
      <name>hessianGradientNCycles</name>
      <anchor>MnStrategya10</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>isLow</name>
      <anchor>MnStrategya11</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>isMedium</name>
      <anchor>MnStrategya12</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>isHigh</name>
      <anchor>MnStrategya13</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setLowStrategy</name>
      <anchor>MnStrategya14</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setMediumStrategy</name>
      <anchor>MnStrategya15</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setHighStrategy</name>
      <anchor>MnStrategya16</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setGradientNCycles</name>
      <anchor>MnStrategya17</anchor>
      <arglist>(unsigned int n)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setGradientStepTolerance</name>
      <anchor>MnStrategya18</anchor>
      <arglist>(double stp)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setGradientTolerance</name>
      <anchor>MnStrategya19</anchor>
      <arglist>(double toler)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setHessianNCycles</name>
      <anchor>MnStrategya20</anchor>
      <arglist>(unsigned int n)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setHessianStepTolerance</name>
      <anchor>MnStrategya21</anchor>
      <arglist>(double stp)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setHessianG2Tolerance</name>
      <anchor>MnStrategya22</anchor>
      <arglist>(double toler)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setHessianGradientNCycles</name>
      <anchor>MnStrategya23</anchor>
      <arglist>(unsigned int n)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>unsigned int</type>
      <name>theStrategy</name>
      <anchor>MnStrategyr0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>unsigned int</type>
      <name>theGradNCyc</name>
      <anchor>MnStrategyr1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theGradTlrStp</name>
      <anchor>MnStrategyr2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theGradTlr</name>
      <anchor>MnStrategyr3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>unsigned int</type>
      <name>theHessNCyc</name>
      <anchor>MnStrategyr4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theHessTlrStp</name>
      <anchor>MnStrategyr5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theHessTlrG2</name>
      <anchor>MnStrategyr6</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>unsigned int</type>
      <name>theHessGradNCyc</name>
      <anchor>MnStrategyr7</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>MnTimer</name>
    <filename>classMnTimer.html</filename>
    <member kind="typedef">
      <type>unsigned long long int</type>
      <name>PentiumTimeType</name>
      <anchor>MnTimerw0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>long long int</type>
      <name>PentiumTimeIntervalType</name>
      <anchor>MnTimerw1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>PentiumTimeType</type>
      <name>TimeType</name>
      <anchor>MnTimerw2</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" static="yes">
      <type>TimeType</type>
      <name>time</name>
      <anchor>MnTimere0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>MnTiny</name>
    <filename>classMnTiny.html</filename>
    <member kind="function">
      <type></type>
      <name>MnTiny</name>
      <anchor>MnTinya0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~MnTiny</name>
      <anchor>MnTinya1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>one</name>
      <anchor>MnTinya2</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>operator()</name>
      <anchor>MnTinya3</anchor>
      <arglist>(double epsp1) const </arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theOne</name>
      <anchor>MnTinyr0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>MnUserCovariance</name>
    <filename>classMnUserCovariance.html</filename>
    <member kind="function">
      <type></type>
      <name>MnUserCovariance</name>
      <anchor>MnUserCovariancea0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>MnUserCovariance</name>
      <anchor>MnUserCovariancea1</anchor>
      <arglist>(const std::vector&lt; double &gt; &amp;data, unsigned int nrow)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>MnUserCovariance</name>
      <anchor>MnUserCovariancea2</anchor>
      <arglist>(unsigned int n)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~MnUserCovariance</name>
      <anchor>MnUserCovariancea3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>MnUserCovariance</name>
      <anchor>MnUserCovariancea4</anchor>
      <arglist>(const MnUserCovariance &amp;cov)</arglist>
    </member>
    <member kind="function">
      <type>MnUserCovariance &amp;</type>
      <name>operator=</name>
      <anchor>MnUserCovariancea5</anchor>
      <arglist>(const MnUserCovariance &amp;cov)</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>operator()</name>
      <anchor>MnUserCovariancea6</anchor>
      <arglist>(unsigned int row, unsigned int col) const </arglist>
    </member>
    <member kind="function">
      <type>double &amp;</type>
      <name>operator()</name>
      <anchor>MnUserCovariancea7</anchor>
      <arglist>(unsigned int row, unsigned int col)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>scale</name>
      <anchor>MnUserCovariancea8</anchor>
      <arglist>(double f)</arglist>
    </member>
    <member kind="function">
      <type>const std::vector&lt; double &gt; &amp;</type>
      <name>data</name>
      <anchor>MnUserCovariancea9</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>unsigned int</type>
      <name>nrow</name>
      <anchor>MnUserCovariancea10</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>unsigned int</type>
      <name>size</name>
      <anchor>MnUserCovariancea11</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="variable" protection="private">
      <type>std::vector&lt; double &gt;</type>
      <name>theData</name>
      <anchor>MnUserCovariancer0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>unsigned int</type>
      <name>theNRow</name>
      <anchor>MnUserCovariancer1</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>MnUserFcn</name>
    <filename>classMnUserFcn.html</filename>
    <base>MnFcn</base>
    <member kind="function">
      <type></type>
      <name>MnUserFcn</name>
      <anchor>MnUserFcna0</anchor>
      <arglist>(const FCNBase &amp;fcn, const MnUserTransformation &amp;trafo)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~MnUserFcn</name>
      <anchor>MnUserFcna1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual double</type>
      <name>operator()</name>
      <anchor>MnUserFcna2</anchor>
      <arglist>(const MnAlgebraicVector &amp;) const </arglist>
    </member>
    <member kind="function">
      <type>unsigned int</type>
      <name>numOfCalls</name>
      <anchor>MnUserFcna3</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>errorDef</name>
      <anchor>MnUserFcna4</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>up</name>
      <anchor>MnUserFcna5</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const FCNBase &amp;</type>
      <name>fcn</name>
      <anchor>MnUserFcna6</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>int</type>
      <name>theNumCall</name>
      <anchor>MnUserFcnp0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>const MnUserTransformation &amp;</type>
      <name>theTransform</name>
      <anchor>MnUserFcnr0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>MnUserParameters</name>
    <filename>classMnUserParameters.html</filename>
    <member kind="function">
      <type></type>
      <name>MnUserParameters</name>
      <anchor>MnUserParametersa0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>MnUserParameters</name>
      <anchor>MnUserParametersa1</anchor>
      <arglist>(const std::vector&lt; double &gt; &amp;, const std::vector&lt; double &gt; &amp;)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~MnUserParameters</name>
      <anchor>MnUserParametersa2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>MnUserParameters</name>
      <anchor>MnUserParametersa3</anchor>
      <arglist>(const MnUserParameters &amp;par)</arglist>
    </member>
    <member kind="function">
      <type>MnUserParameters &amp;</type>
      <name>operator=</name>
      <anchor>MnUserParametersa4</anchor>
      <arglist>(const MnUserParameters &amp;par)</arglist>
    </member>
    <member kind="function">
      <type>const MnUserTransformation &amp;</type>
      <name>trafo</name>
      <anchor>MnUserParametersa5</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>unsigned int</type>
      <name>variableParameters</name>
      <anchor>MnUserParametersa6</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const std::vector&lt; MinuitParameter &gt; &amp;</type>
      <name>parameters</name>
      <anchor>MnUserParametersa7</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>std::vector&lt; double &gt;</type>
      <name>params</name>
      <anchor>MnUserParametersa8</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>std::vector&lt; double &gt;</type>
      <name>errors</name>
      <anchor>MnUserParametersa9</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const MinuitParameter &amp;</type>
      <name>parameter</name>
      <anchor>MnUserParametersa10</anchor>
      <arglist>(unsigned int) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>add</name>
      <anchor>MnUserParametersa11</anchor>
      <arglist>(const char *, double, double)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>add</name>
      <anchor>MnUserParametersa12</anchor>
      <arglist>(const char *, double, double, double, double)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>add</name>
      <anchor>MnUserParametersa13</anchor>
      <arglist>(const char *, double)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>fix</name>
      <anchor>MnUserParametersa14</anchor>
      <arglist>(unsigned int)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>release</name>
      <anchor>MnUserParametersa15</anchor>
      <arglist>(unsigned int)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setValue</name>
      <anchor>MnUserParametersa16</anchor>
      <arglist>(unsigned int, double)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setError</name>
      <anchor>MnUserParametersa17</anchor>
      <arglist>(unsigned int, double)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setLimits</name>
      <anchor>MnUserParametersa18</anchor>
      <arglist>(unsigned int, double, double)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setUpperLimit</name>
      <anchor>MnUserParametersa19</anchor>
      <arglist>(unsigned int, double)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setLowerLimit</name>
      <anchor>MnUserParametersa20</anchor>
      <arglist>(unsigned int, double)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>removeLimits</name>
      <anchor>MnUserParametersa21</anchor>
      <arglist>(unsigned int)</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>value</name>
      <anchor>MnUserParametersa22</anchor>
      <arglist>(unsigned int) const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>error</name>
      <anchor>MnUserParametersa23</anchor>
      <arglist>(unsigned int) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>fix</name>
      <anchor>MnUserParametersa24</anchor>
      <arglist>(const char *)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>release</name>
      <anchor>MnUserParametersa25</anchor>
      <arglist>(const char *)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setValue</name>
      <anchor>MnUserParametersa26</anchor>
      <arglist>(const char *, double)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setError</name>
      <anchor>MnUserParametersa27</anchor>
      <arglist>(const char *, double)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setLimits</name>
      <anchor>MnUserParametersa28</anchor>
      <arglist>(const char *, double, double)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setUpperLimit</name>
      <anchor>MnUserParametersa29</anchor>
      <arglist>(const char *, double)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setLowerLimit</name>
      <anchor>MnUserParametersa30</anchor>
      <arglist>(const char *, double)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>removeLimits</name>
      <anchor>MnUserParametersa31</anchor>
      <arglist>(const char *)</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>value</name>
      <anchor>MnUserParametersa32</anchor>
      <arglist>(const char *) const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>error</name>
      <anchor>MnUserParametersa33</anchor>
      <arglist>(const char *) const </arglist>
    </member>
    <member kind="function">
      <type>unsigned int</type>
      <name>index</name>
      <anchor>MnUserParametersa34</anchor>
      <arglist>(const char *) const </arglist>
    </member>
    <member kind="function">
      <type>const char *</type>
      <name>name</name>
      <anchor>MnUserParametersa35</anchor>
      <arglist>(unsigned int) const </arglist>
    </member>
    <member kind="function">
      <type>const MnMachinePrecision &amp;</type>
      <name>precision</name>
      <anchor>MnUserParametersa36</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setPrecision</name>
      <anchor>MnUserParametersa37</anchor>
      <arglist>(double eps)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>MnUserTransformation</type>
      <name>theTransformation</name>
      <anchor>MnUserParametersr0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>MnUserParameterState</name>
    <filename>classMnUserParameterState.html</filename>
    <member kind="function">
      <type></type>
      <name>MnUserParameterState</name>
      <anchor>MnUserParameterStatea0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>MnUserParameterState</name>
      <anchor>MnUserParameterStatea1</anchor>
      <arglist>(const std::vector&lt; double &gt; &amp;, const std::vector&lt; double &gt; &amp;)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>MnUserParameterState</name>
      <anchor>MnUserParameterStatea2</anchor>
      <arglist>(const MnUserParameters &amp;)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>MnUserParameterState</name>
      <anchor>MnUserParameterStatea3</anchor>
      <arglist>(const std::vector&lt; double &gt; &amp;, const std::vector&lt; double &gt; &amp;, unsigned int)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>MnUserParameterState</name>
      <anchor>MnUserParameterStatea4</anchor>
      <arglist>(const std::vector&lt; double &gt; &amp;, const MnUserCovariance &amp;)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>MnUserParameterState</name>
      <anchor>MnUserParameterStatea5</anchor>
      <arglist>(const MnUserParameters &amp;, const MnUserCovariance &amp;)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>MnUserParameterState</name>
      <anchor>MnUserParameterStatea6</anchor>
      <arglist>(const MinimumState &amp;, double, const MnUserTransformation &amp;)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~MnUserParameterState</name>
      <anchor>MnUserParameterStatea7</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>MnUserParameterState</name>
      <anchor>MnUserParameterStatea8</anchor>
      <arglist>(const MnUserParameterState &amp;state)</arglist>
    </member>
    <member kind="function">
      <type>MnUserParameterState &amp;</type>
      <name>operator=</name>
      <anchor>MnUserParameterStatea9</anchor>
      <arglist>(const MnUserParameterState &amp;state)</arglist>
    </member>
    <member kind="function">
      <type>const MnUserParameters &amp;</type>
      <name>parameters</name>
      <anchor>MnUserParameterStatea10</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const MnUserCovariance &amp;</type>
      <name>covariance</name>
      <anchor>MnUserParameterStatea11</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const MnGlobalCorrelationCoeff &amp;</type>
      <name>globalCC</name>
      <anchor>MnUserParameterStatea12</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const std::vector&lt; double &gt; &amp;</type>
      <name>intParameters</name>
      <anchor>MnUserParameterStatea13</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const MnUserCovariance &amp;</type>
      <name>intCovariance</name>
      <anchor>MnUserParameterStatea14</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const MnUserTransformation &amp;</type>
      <name>trafo</name>
      <anchor>MnUserParameterStatea15</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>isValid</name>
      <anchor>MnUserParameterStatea16</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>hasCovariance</name>
      <anchor>MnUserParameterStatea17</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>hasGlobalCC</name>
      <anchor>MnUserParameterStatea18</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>fval</name>
      <anchor>MnUserParameterStatea19</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>edm</name>
      <anchor>MnUserParameterStatea20</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>unsigned int</type>
      <name>nfcn</name>
      <anchor>MnUserParameterStatea21</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const std::vector&lt; MinuitParameter &gt; &amp;</type>
      <name>minuitParameters</name>
      <anchor>MnUserParameterStatea22</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>std::vector&lt; double &gt;</type>
      <name>params</name>
      <anchor>MnUserParameterStatea23</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>std::vector&lt; double &gt;</type>
      <name>errors</name>
      <anchor>MnUserParameterStatea24</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const MinuitParameter &amp;</type>
      <name>parameter</name>
      <anchor>MnUserParameterStatea25</anchor>
      <arglist>(unsigned int i) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>add</name>
      <anchor>MnUserParameterStatea26</anchor>
      <arglist>(const char *name, double val, double err)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>add</name>
      <anchor>MnUserParameterStatea27</anchor>
      <arglist>(const char *name, double val, double err, double, double)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>add</name>
      <anchor>MnUserParameterStatea28</anchor>
      <arglist>(const char *, double)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>fix</name>
      <anchor>MnUserParameterStatea29</anchor>
      <arglist>(unsigned int)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>release</name>
      <anchor>MnUserParameterStatea30</anchor>
      <arglist>(unsigned int)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setValue</name>
      <anchor>MnUserParameterStatea31</anchor>
      <arglist>(unsigned int, double)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setError</name>
      <anchor>MnUserParameterStatea32</anchor>
      <arglist>(unsigned int, double)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setLimits</name>
      <anchor>MnUserParameterStatea33</anchor>
      <arglist>(unsigned int, double, double)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setUpperLimit</name>
      <anchor>MnUserParameterStatea34</anchor>
      <arglist>(unsigned int, double)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setLowerLimit</name>
      <anchor>MnUserParameterStatea35</anchor>
      <arglist>(unsigned int, double)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>removeLimits</name>
      <anchor>MnUserParameterStatea36</anchor>
      <arglist>(unsigned int)</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>value</name>
      <anchor>MnUserParameterStatea37</anchor>
      <arglist>(unsigned int) const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>error</name>
      <anchor>MnUserParameterStatea38</anchor>
      <arglist>(unsigned int) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>fix</name>
      <anchor>MnUserParameterStatea39</anchor>
      <arglist>(const char *)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>release</name>
      <anchor>MnUserParameterStatea40</anchor>
      <arglist>(const char *)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setValue</name>
      <anchor>MnUserParameterStatea41</anchor>
      <arglist>(const char *, double)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setError</name>
      <anchor>MnUserParameterStatea42</anchor>
      <arglist>(const char *, double)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setLimits</name>
      <anchor>MnUserParameterStatea43</anchor>
      <arglist>(const char *, double, double)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setUpperLimit</name>
      <anchor>MnUserParameterStatea44</anchor>
      <arglist>(const char *, double)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setLowerLimit</name>
      <anchor>MnUserParameterStatea45</anchor>
      <arglist>(const char *, double)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>removeLimits</name>
      <anchor>MnUserParameterStatea46</anchor>
      <arglist>(const char *)</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>value</name>
      <anchor>MnUserParameterStatea47</anchor>
      <arglist>(const char *) const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>error</name>
      <anchor>MnUserParameterStatea48</anchor>
      <arglist>(const char *) const </arglist>
    </member>
    <member kind="function">
      <type>unsigned int</type>
      <name>index</name>
      <anchor>MnUserParameterStatea49</anchor>
      <arglist>(const char *) const </arglist>
    </member>
    <member kind="function">
      <type>const char *</type>
      <name>name</name>
      <anchor>MnUserParameterStatea50</anchor>
      <arglist>(unsigned int) const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>int2ext</name>
      <anchor>MnUserParameterStatea51</anchor>
      <arglist>(unsigned int, double) const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>ext2int</name>
      <anchor>MnUserParameterStatea52</anchor>
      <arglist>(unsigned int, double) const </arglist>
    </member>
    <member kind="function">
      <type>unsigned int</type>
      <name>intOfExt</name>
      <anchor>MnUserParameterStatea53</anchor>
      <arglist>(unsigned int) const </arglist>
    </member>
    <member kind="function">
      <type>unsigned int</type>
      <name>extOfInt</name>
      <anchor>MnUserParameterStatea54</anchor>
      <arglist>(unsigned int) const </arglist>
    </member>
    <member kind="function">
      <type>unsigned int</type>
      <name>variableParameters</name>
      <anchor>MnUserParameterStatea55</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const MnMachinePrecision &amp;</type>
      <name>precision</name>
      <anchor>MnUserParameterStatea56</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setPrecision</name>
      <anchor>MnUserParameterStatea57</anchor>
      <arglist>(double eps)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool</type>
      <name>theValid</name>
      <anchor>MnUserParameterStater0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool</type>
      <name>theCovarianceValid</name>
      <anchor>MnUserParameterStater1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool</type>
      <name>theGCCValid</name>
      <anchor>MnUserParameterStater2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theFVal</name>
      <anchor>MnUserParameterStater3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theEDM</name>
      <anchor>MnUserParameterStater4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>unsigned int</type>
      <name>theNFcn</name>
      <anchor>MnUserParameterStater5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>MnUserParameters</type>
      <name>theParameters</name>
      <anchor>MnUserParameterStater6</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>MnUserCovariance</type>
      <name>theCovariance</name>
      <anchor>MnUserParameterStater7</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>MnGlobalCorrelationCoeff</type>
      <name>theGlobalCC</name>
      <anchor>MnUserParameterStater8</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>std::vector&lt; double &gt;</type>
      <name>theIntParameters</name>
      <anchor>MnUserParameterStater9</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>MnUserCovariance</type>
      <name>theIntCovariance</name>
      <anchor>MnUserParameterStater10</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>MnUserTransformation</name>
    <filename>classMnUserTransformation.html</filename>
    <member kind="function">
      <type></type>
      <name>MnUserTransformation</name>
      <anchor>MnUserTransformationa0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>MnUserTransformation</name>
      <anchor>MnUserTransformationa1</anchor>
      <arglist>(const std::vector&lt; double &gt; &amp;, const std::vector&lt; double &gt; &amp;)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~MnUserTransformation</name>
      <anchor>MnUserTransformationa2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>MnUserTransformation</name>
      <anchor>MnUserTransformationa3</anchor>
      <arglist>(const MnUserTransformation &amp;trafo)</arglist>
    </member>
    <member kind="function">
      <type>MnUserTransformation &amp;</type>
      <name>operator=</name>
      <anchor>MnUserTransformationa4</anchor>
      <arglist>(const MnUserTransformation &amp;trafo)</arglist>
    </member>
    <member kind="function">
      <type>const std::vector&lt; double &gt; &amp;</type>
      <name>operator()</name>
      <anchor>MnUserTransformationa5</anchor>
      <arglist>(const MnAlgebraicVector &amp;) const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>int2ext</name>
      <anchor>MnUserTransformationa6</anchor>
      <arglist>(unsigned int, double) const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>int2extError</name>
      <anchor>MnUserTransformationa7</anchor>
      <arglist>(unsigned int, double, double) const </arglist>
    </member>
    <member kind="function">
      <type>MnUserCovariance</type>
      <name>int2extCovariance</name>
      <anchor>MnUserTransformationa8</anchor>
      <arglist>(const MnAlgebraicVector &amp;, const MnAlgebraicSymMatrix &amp;) const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>ext2int</name>
      <anchor>MnUserTransformationa9</anchor>
      <arglist>(unsigned int, double) const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>dInt2Ext</name>
      <anchor>MnUserTransformationa10</anchor>
      <arglist>(unsigned int, double) const </arglist>
    </member>
    <member kind="function">
      <type>unsigned int</type>
      <name>intOfExt</name>
      <anchor>MnUserTransformationa11</anchor>
      <arglist>(unsigned int) const </arglist>
    </member>
    <member kind="function">
      <type>unsigned int</type>
      <name>extOfInt</name>
      <anchor>MnUserTransformationa12</anchor>
      <arglist>(unsigned int internal) const </arglist>
    </member>
    <member kind="function">
      <type>const std::vector&lt; MinuitParameter &gt; &amp;</type>
      <name>parameters</name>
      <anchor>MnUserTransformationa13</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>unsigned int</type>
      <name>variableParameters</name>
      <anchor>MnUserTransformationa14</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const MnMachinePrecision &amp;</type>
      <name>precision</name>
      <anchor>MnUserTransformationa15</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setPrecision</name>
      <anchor>MnUserTransformationa16</anchor>
      <arglist>(double eps)</arglist>
    </member>
    <member kind="function">
      <type>std::vector&lt; double &gt;</type>
      <name>params</name>
      <anchor>MnUserTransformationa17</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>std::vector&lt; double &gt;</type>
      <name>errors</name>
      <anchor>MnUserTransformationa18</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const MinuitParameter &amp;</type>
      <name>parameter</name>
      <anchor>MnUserTransformationa19</anchor>
      <arglist>(unsigned int) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>add</name>
      <anchor>MnUserTransformationa20</anchor>
      <arglist>(const char *, double, double)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>add</name>
      <anchor>MnUserTransformationa21</anchor>
      <arglist>(const char *, double, double, double, double)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>add</name>
      <anchor>MnUserTransformationa22</anchor>
      <arglist>(const char *, double)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>fix</name>
      <anchor>MnUserTransformationa23</anchor>
      <arglist>(unsigned int)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>release</name>
      <anchor>MnUserTransformationa24</anchor>
      <arglist>(unsigned int)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setValue</name>
      <anchor>MnUserTransformationa25</anchor>
      <arglist>(unsigned int, double)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setError</name>
      <anchor>MnUserTransformationa26</anchor>
      <arglist>(unsigned int, double)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setLimits</name>
      <anchor>MnUserTransformationa27</anchor>
      <arglist>(unsigned int, double, double)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setUpperLimit</name>
      <anchor>MnUserTransformationa28</anchor>
      <arglist>(unsigned int, double)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setLowerLimit</name>
      <anchor>MnUserTransformationa29</anchor>
      <arglist>(unsigned int, double)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>removeLimits</name>
      <anchor>MnUserTransformationa30</anchor>
      <arglist>(unsigned int)</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>value</name>
      <anchor>MnUserTransformationa31</anchor>
      <arglist>(unsigned int) const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>error</name>
      <anchor>MnUserTransformationa32</anchor>
      <arglist>(unsigned int) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>fix</name>
      <anchor>MnUserTransformationa33</anchor>
      <arglist>(const char *)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>release</name>
      <anchor>MnUserTransformationa34</anchor>
      <arglist>(const char *)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setValue</name>
      <anchor>MnUserTransformationa35</anchor>
      <arglist>(const char *, double)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setError</name>
      <anchor>MnUserTransformationa36</anchor>
      <arglist>(const char *, double)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setLimits</name>
      <anchor>MnUserTransformationa37</anchor>
      <arglist>(const char *, double, double)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setUpperLimit</name>
      <anchor>MnUserTransformationa38</anchor>
      <arglist>(const char *, double)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setLowerLimit</name>
      <anchor>MnUserTransformationa39</anchor>
      <arglist>(const char *, double)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>removeLimits</name>
      <anchor>MnUserTransformationa40</anchor>
      <arglist>(const char *)</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>value</name>
      <anchor>MnUserTransformationa41</anchor>
      <arglist>(const char *) const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>error</name>
      <anchor>MnUserTransformationa42</anchor>
      <arglist>(const char *) const </arglist>
    </member>
    <member kind="function">
      <type>unsigned int</type>
      <name>index</name>
      <anchor>MnUserTransformationa43</anchor>
      <arglist>(const char *) const </arglist>
    </member>
    <member kind="function">
      <type>const char *</type>
      <name>name</name>
      <anchor>MnUserTransformationa44</anchor>
      <arglist>(unsigned int) const </arglist>
    </member>
    <member kind="variable" protection="private">
      <type>MnMachinePrecision</type>
      <name>thePrecision</name>
      <anchor>MnUserTransformationr0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>std::vector&lt; MinuitParameter &gt;</type>
      <name>theParameters</name>
      <anchor>MnUserTransformationr1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>std::vector&lt; unsigned int &gt;</type>
      <name>theExtOfInt</name>
      <anchor>MnUserTransformationr2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>SinParameterTransformation</type>
      <name>theDoubleLimTrafo</name>
      <anchor>MnUserTransformationr3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>SqrtUpParameterTransformation</type>
      <name>theUpperLimTrafo</name>
      <anchor>MnUserTransformationr4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>SqrtLowParameterTransformation</type>
      <name>theLowerLimTrafo</name>
      <anchor>MnUserTransformationr5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>std::vector&lt; double &gt;</type>
      <name>theCache</name>
      <anchor>MnUserTransformationr6</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>MnVectorTransform</name>
    <filename>classMnVectorTransform.html</filename>
    <member kind="function">
      <type></type>
      <name>MnVectorTransform</name>
      <anchor>MnVectorTransforma0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~MnVectorTransform</name>
      <anchor>MnVectorTransforma1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>std::vector&lt; double &gt;</type>
      <name>operator()</name>
      <anchor>MnVectorTransforma2</anchor>
      <arglist>(const MnAlgebraicVector &amp;avec) const </arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ModularFunctionMinimizer</name>
    <filename>classModularFunctionMinimizer.html</filename>
    <base>FunctionMinimizer</base>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~ModularFunctionMinimizer</name>
      <anchor>ModularFunctionMinimizera0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual FunctionMinimum</type>
      <name>minimize</name>
      <anchor>VariableMetricMinimizera4</anchor>
      <arglist>(const FCNBase &amp;, const std::vector&lt; double &gt; &amp;, const std::vector&lt; double &gt; &amp;, unsigned int stra=1, unsigned int maxfcn=0, double toler=0.1) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual FunctionMinimum</type>
      <name>minimize</name>
      <anchor>VariableMetricMinimizera5</anchor>
      <arglist>(const FCNGradientBase &amp;, const std::vector&lt; double &gt; &amp;, const std::vector&lt; double &gt; &amp;, unsigned int stra=1, unsigned int maxfcn=0, double toler=0.1) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual FunctionMinimum</type>
      <name>minimize</name>
      <anchor>VariableMetricMinimizera6</anchor>
      <arglist>(const FCNBase &amp;, const std::vector&lt; double &gt; &amp;, const std::vector&lt; double &gt; &amp;, unsigned int, unsigned int stra=1, unsigned int maxfcn=0, double toler=0.1) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual FunctionMinimum</type>
      <name>minimize</name>
      <anchor>VariableMetricMinimizera7</anchor>
      <arglist>(const FCNGradientBase &amp;, const std::vector&lt; double &gt; &amp;, const std::vector&lt; double &gt; &amp;, unsigned int, unsigned int stra=1, unsigned int maxfcn=0, double toler=0.1) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual FunctionMinimum</type>
      <name>minimize</name>
      <anchor>VariableMetricMinimizera8</anchor>
      <arglist>(const FCNBase &amp;, const MnUserParameters &amp;, const MnStrategy &amp;, unsigned int maxfcn=0, double toler=0.1) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual FunctionMinimum</type>
      <name>minimize</name>
      <anchor>VariableMetricMinimizera9</anchor>
      <arglist>(const FCNBase &amp;, const MnUserParameters &amp;, const MnUserCovariance &amp;, const MnStrategy &amp;, unsigned int maxfcn=0, double toler=0.1) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual FunctionMinimum</type>
      <name>minimize</name>
      <anchor>VariableMetricMinimizera10</anchor>
      <arglist>(const FCNBase &amp;, const MnUserParameterState &amp;, const MnStrategy &amp;, unsigned int maxfcn=0, double toler=0.1) const </arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual const MinimumSeedGenerator &amp;</type>
      <name>seedGenerator</name>
      <anchor>ModularFunctionMinimizera8</anchor>
      <arglist>() const =0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual const MinimumBuilder &amp;</type>
      <name>builder</name>
      <anchor>ModularFunctionMinimizera9</anchor>
      <arglist>() const =0</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual FunctionMinimum</type>
      <name>minimize</name>
      <anchor>VariableMetricMinimizera11</anchor>
      <arglist>(const MnFcn &amp;, const GradientCalculator &amp;, const MinimumSeed &amp;, const MnStrategy &amp;, unsigned int, double) const </arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>NegativeG2LineSearch</name>
    <filename>classNegativeG2LineSearch.html</filename>
    <member kind="function">
      <type></type>
      <name>NegativeG2LineSearch</name>
      <anchor>NegativeG2LineSearcha0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~NegativeG2LineSearch</name>
      <anchor>NegativeG2LineSearcha1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>MinimumState</type>
      <name>operator()</name>
      <anchor>NegativeG2LineSearcha2</anchor>
      <arglist>(const MnFcn &amp;, const MinimumState &amp;, const GradientCalculator &amp;, const MnMachinePrecision &amp;) const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>hasNegativeG2</name>
      <anchor>NegativeG2LineSearcha3</anchor>
      <arglist>(const FunctionGradient &amp;, const MnMachinePrecision &amp;) const </arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>Numerical2PGradientCalculator</name>
    <filename>classNumerical2PGradientCalculator.html</filename>
    <base>GradientCalculator</base>
    <member kind="function">
      <type></type>
      <name>Numerical2PGradientCalculator</name>
      <anchor>Numerical2PGradientCalculatora0</anchor>
      <arglist>(const MnFcn &amp;fcn, const MnUserTransformation &amp;par, const MnStrategy &amp;stra)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~Numerical2PGradientCalculator</name>
      <anchor>Numerical2PGradientCalculatora1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual FunctionGradient</type>
      <name>operator()</name>
      <anchor>Numerical2PGradientCalculatora2</anchor>
      <arglist>(const MinimumParameters &amp;) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual FunctionGradient</type>
      <name>operator()</name>
      <anchor>Numerical2PGradientCalculatora3</anchor>
      <arglist>(const MinimumParameters &amp;, const FunctionGradient &amp;) const </arglist>
    </member>
    <member kind="function">
      <type>const MnFcn &amp;</type>
      <name>fcn</name>
      <anchor>Numerical2PGradientCalculatora4</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const MnUserTransformation &amp;</type>
      <name>trafo</name>
      <anchor>Numerical2PGradientCalculatora5</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const MnMachinePrecision &amp;</type>
      <name>precision</name>
      <anchor>Numerical2PGradientCalculatora6</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const MnStrategy &amp;</type>
      <name>strategy</name>
      <anchor>Numerical2PGradientCalculatora7</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>unsigned int</type>
      <name>ncycle</name>
      <anchor>Numerical2PGradientCalculatora8</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>stepTolerance</name>
      <anchor>Numerical2PGradientCalculatora9</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>gradTolerance</name>
      <anchor>Numerical2PGradientCalculatora10</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="variable" protection="private">
      <type>const MnFcn &amp;</type>
      <name>theFcn</name>
      <anchor>Numerical2PGradientCalculatorr0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>const MnUserTransformation &amp;</type>
      <name>theTransformation</name>
      <anchor>Numerical2PGradientCalculatorr1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>const MnStrategy &amp;</type>
      <name>theStrategy</name>
      <anchor>Numerical2PGradientCalculatorr2</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ScanBuilder</name>
    <filename>classScanBuilder.html</filename>
    <base>MinimumBuilder</base>
    <member kind="function">
      <type></type>
      <name>ScanBuilder</name>
      <anchor>ScanBuildera0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~ScanBuilder</name>
      <anchor>ScanBuildera1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual FunctionMinimum</type>
      <name>minimum</name>
      <anchor>ScanBuildera2</anchor>
      <arglist>(const MnFcn &amp;, const GradientCalculator &amp;, const MinimumSeed &amp;, const MnStrategy &amp;, unsigned int, double) const </arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ScanMinimizer</name>
    <filename>classScanMinimizer.html</filename>
    <base>ModularFunctionMinimizer</base>
    <member kind="function">
      <type></type>
      <name>ScanMinimizer</name>
      <anchor>ScanMinimizera0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~ScanMinimizer</name>
      <anchor>ScanMinimizera1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>const MinimumSeedGenerator &amp;</type>
      <name>seedGenerator</name>
      <anchor>ScanMinimizera2</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const MinimumBuilder &amp;</type>
      <name>builder</name>
      <anchor>ScanMinimizera3</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual FunctionMinimum</type>
      <name>minimize</name>
      <anchor>VariableMetricMinimizera4</anchor>
      <arglist>(const FCNBase &amp;, const std::vector&lt; double &gt; &amp;, const std::vector&lt; double &gt; &amp;, unsigned int stra=1, unsigned int maxfcn=0, double toler=0.1) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual FunctionMinimum</type>
      <name>minimize</name>
      <anchor>VariableMetricMinimizera5</anchor>
      <arglist>(const FCNGradientBase &amp;, const std::vector&lt; double &gt; &amp;, const std::vector&lt; double &gt; &amp;, unsigned int stra=1, unsigned int maxfcn=0, double toler=0.1) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual FunctionMinimum</type>
      <name>minimize</name>
      <anchor>VariableMetricMinimizera6</anchor>
      <arglist>(const FCNBase &amp;, const std::vector&lt; double &gt; &amp;, const std::vector&lt; double &gt; &amp;, unsigned int, unsigned int stra=1, unsigned int maxfcn=0, double toler=0.1) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual FunctionMinimum</type>
      <name>minimize</name>
      <anchor>VariableMetricMinimizera7</anchor>
      <arglist>(const FCNGradientBase &amp;, const std::vector&lt; double &gt; &amp;, const std::vector&lt; double &gt; &amp;, unsigned int, unsigned int stra=1, unsigned int maxfcn=0, double toler=0.1) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual FunctionMinimum</type>
      <name>minimize</name>
      <anchor>VariableMetricMinimizera8</anchor>
      <arglist>(const FCNBase &amp;, const MnUserParameters &amp;, const MnStrategy &amp;, unsigned int maxfcn=0, double toler=0.1) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual FunctionMinimum</type>
      <name>minimize</name>
      <anchor>VariableMetricMinimizera9</anchor>
      <arglist>(const FCNBase &amp;, const MnUserParameters &amp;, const MnUserCovariance &amp;, const MnStrategy &amp;, unsigned int maxfcn=0, double toler=0.1) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual FunctionMinimum</type>
      <name>minimize</name>
      <anchor>VariableMetricMinimizera10</anchor>
      <arglist>(const FCNBase &amp;, const MnUserParameterState &amp;, const MnStrategy &amp;, unsigned int maxfcn=0, double toler=0.1) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual FunctionMinimum</type>
      <name>minimize</name>
      <anchor>VariableMetricMinimizera11</anchor>
      <arglist>(const MnFcn &amp;, const GradientCalculator &amp;, const MinimumSeed &amp;, const MnStrategy &amp;, unsigned int, double) const </arglist>
    </member>
    <member kind="variable" protection="private">
      <type>SimplexSeedGenerator</type>
      <name>theSeedGenerator</name>
      <anchor>ScanMinimizerr0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ScanBuilder</type>
      <name>theBuilder</name>
      <anchor>ScanMinimizerr1</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>SimplexBuilder</name>
    <filename>classSimplexBuilder.html</filename>
    <base>MinimumBuilder</base>
    <member kind="function">
      <type></type>
      <name>SimplexBuilder</name>
      <anchor>SimplexBuildera0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~SimplexBuilder</name>
      <anchor>SimplexBuildera1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual FunctionMinimum</type>
      <name>minimum</name>
      <anchor>SimplexBuildera2</anchor>
      <arglist>(const MnFcn &amp;, const GradientCalculator &amp;, const MinimumSeed &amp;, const MnStrategy &amp;, unsigned int, double) const </arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>SimplexMinimizer</name>
    <filename>classSimplexMinimizer.html</filename>
    <base>ModularFunctionMinimizer</base>
    <member kind="function">
      <type></type>
      <name>SimplexMinimizer</name>
      <anchor>SimplexMinimizera0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~SimplexMinimizer</name>
      <anchor>SimplexMinimizera1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>const MinimumSeedGenerator &amp;</type>
      <name>seedGenerator</name>
      <anchor>SimplexMinimizera2</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const MinimumBuilder &amp;</type>
      <name>builder</name>
      <anchor>SimplexMinimizera3</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual FunctionMinimum</type>
      <name>minimize</name>
      <anchor>VariableMetricMinimizera4</anchor>
      <arglist>(const FCNBase &amp;, const std::vector&lt; double &gt; &amp;, const std::vector&lt; double &gt; &amp;, unsigned int stra=1, unsigned int maxfcn=0, double toler=0.1) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual FunctionMinimum</type>
      <name>minimize</name>
      <anchor>VariableMetricMinimizera5</anchor>
      <arglist>(const FCNGradientBase &amp;, const std::vector&lt; double &gt; &amp;, const std::vector&lt; double &gt; &amp;, unsigned int stra=1, unsigned int maxfcn=0, double toler=0.1) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual FunctionMinimum</type>
      <name>minimize</name>
      <anchor>VariableMetricMinimizera6</anchor>
      <arglist>(const FCNBase &amp;, const std::vector&lt; double &gt; &amp;, const std::vector&lt; double &gt; &amp;, unsigned int, unsigned int stra=1, unsigned int maxfcn=0, double toler=0.1) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual FunctionMinimum</type>
      <name>minimize</name>
      <anchor>VariableMetricMinimizera7</anchor>
      <arglist>(const FCNGradientBase &amp;, const std::vector&lt; double &gt; &amp;, const std::vector&lt; double &gt; &amp;, unsigned int, unsigned int stra=1, unsigned int maxfcn=0, double toler=0.1) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual FunctionMinimum</type>
      <name>minimize</name>
      <anchor>VariableMetricMinimizera8</anchor>
      <arglist>(const FCNBase &amp;, const MnUserParameters &amp;, const MnStrategy &amp;, unsigned int maxfcn=0, double toler=0.1) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual FunctionMinimum</type>
      <name>minimize</name>
      <anchor>VariableMetricMinimizera9</anchor>
      <arglist>(const FCNBase &amp;, const MnUserParameters &amp;, const MnUserCovariance &amp;, const MnStrategy &amp;, unsigned int maxfcn=0, double toler=0.1) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual FunctionMinimum</type>
      <name>minimize</name>
      <anchor>VariableMetricMinimizera10</anchor>
      <arglist>(const FCNBase &amp;, const MnUserParameterState &amp;, const MnStrategy &amp;, unsigned int maxfcn=0, double toler=0.1) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual FunctionMinimum</type>
      <name>minimize</name>
      <anchor>VariableMetricMinimizera11</anchor>
      <arglist>(const MnFcn &amp;, const GradientCalculator &amp;, const MinimumSeed &amp;, const MnStrategy &amp;, unsigned int, double) const </arglist>
    </member>
    <member kind="variable" protection="private">
      <type>SimplexSeedGenerator</type>
      <name>theSeedGenerator</name>
      <anchor>SimplexMinimizerr0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>SimplexBuilder</type>
      <name>theBuilder</name>
      <anchor>SimplexMinimizerr1</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>SimplexParameters</name>
    <filename>classSimplexParameters.html</filename>
    <member kind="function">
      <type></type>
      <name>SimplexParameters</name>
      <anchor>SimplexParametersa0</anchor>
      <arglist>(const std::vector&lt; std::pair&lt; double, MnAlgebraicVector &gt; &gt; &amp;simpl, unsigned int jh, unsigned int jl)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~SimplexParameters</name>
      <anchor>SimplexParametersa1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>update</name>
      <anchor>SimplexParametersa2</anchor>
      <arglist>(double, const MnAlgebraicVector &amp;)</arglist>
    </member>
    <member kind="function">
      <type>const std::vector&lt; std::pair&lt; double, MnAlgebraicVector &gt; &gt; &amp;</type>
      <name>simplex</name>
      <anchor>SimplexParametersa3</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const std::pair&lt; double, MnAlgebraicVector &gt; &amp;</type>
      <name>operator()</name>
      <anchor>SimplexParametersa4</anchor>
      <arglist>(unsigned int i) const </arglist>
    </member>
    <member kind="function">
      <type>unsigned int</type>
      <name>jh</name>
      <anchor>SimplexParametersa5</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>unsigned int</type>
      <name>jl</name>
      <anchor>SimplexParametersa6</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>edm</name>
      <anchor>SimplexParametersa7</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>MnAlgebraicVector</type>
      <name>dirin</name>
      <anchor>SimplexParametersa8</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="variable" protection="private">
      <type>std::vector&lt; std::pair&lt; double, MnAlgebraicVector &gt; &gt;</type>
      <name>theSimplexParameters</name>
      <anchor>SimplexParametersr0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>unsigned int</type>
      <name>theJHigh</name>
      <anchor>SimplexParametersr1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>unsigned int</type>
      <name>theJLow</name>
      <anchor>SimplexParametersr2</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>SimplexSeedGenerator</name>
    <filename>classSimplexSeedGenerator.html</filename>
    <base>MinimumSeedGenerator</base>
    <member kind="function">
      <type></type>
      <name>SimplexSeedGenerator</name>
      <anchor>SimplexSeedGeneratora0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~SimplexSeedGenerator</name>
      <anchor>SimplexSeedGeneratora1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual MinimumSeed</type>
      <name>operator()</name>
      <anchor>SimplexSeedGeneratora2</anchor>
      <arglist>(const MnFcn &amp;, const GradientCalculator &amp;, const MnUserParameterState &amp;, const MnStrategy &amp;) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual MinimumSeed</type>
      <name>operator()</name>
      <anchor>SimplexSeedGeneratora3</anchor>
      <arglist>(const MnFcn &amp;, const AnalyticalGradientCalculator &amp;, const MnUserParameterState &amp;, const MnStrategy &amp;) const </arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>SinParameterTransformation</name>
    <filename>classSinParameterTransformation.html</filename>
    <member kind="function">
      <type></type>
      <name>SinParameterTransformation</name>
      <anchor>SinParameterTransformationa0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~SinParameterTransformation</name>
      <anchor>SinParameterTransformationa1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>int2ext</name>
      <anchor>SinParameterTransformationa2</anchor>
      <arglist>(double value, double upper, double lower) const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>ext2int</name>
      <anchor>SinParameterTransformationa3</anchor>
      <arglist>(double value, double upper, double lower, const MnMachinePrecision &amp;) const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>dInt2Ext</name>
      <anchor>SinParameterTransformationa4</anchor>
      <arglist>(double value, double upper, double lower) const </arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>SqrtLowParameterTransformation</name>
    <filename>classSqrtLowParameterTransformation.html</filename>
    <member kind="function">
      <type></type>
      <name>SqrtLowParameterTransformation</name>
      <anchor>SqrtLowParameterTransformationa0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~SqrtLowParameterTransformation</name>
      <anchor>SqrtLowParameterTransformationa1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>int2ext</name>
      <anchor>SqrtLowParameterTransformationa2</anchor>
      <arglist>(double value, double lower) const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>ext2int</name>
      <anchor>SqrtLowParameterTransformationa3</anchor>
      <arglist>(double value, double lower, const MnMachinePrecision &amp;) const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>dInt2Ext</name>
      <anchor>SqrtLowParameterTransformationa4</anchor>
      <arglist>(double value, double lower) const </arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>SqrtUpParameterTransformation</name>
    <filename>classSqrtUpParameterTransformation.html</filename>
    <member kind="function">
      <type></type>
      <name>SqrtUpParameterTransformation</name>
      <anchor>SqrtUpParameterTransformationa0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~SqrtUpParameterTransformation</name>
      <anchor>SqrtUpParameterTransformationa1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>int2ext</name>
      <anchor>SqrtUpParameterTransformationa2</anchor>
      <arglist>(double value, double upper) const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>ext2int</name>
      <anchor>SqrtUpParameterTransformationa3</anchor>
      <arglist>(double value, double upper, const MnMachinePrecision &amp;) const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>dInt2Ext</name>
      <anchor>SqrtUpParameterTransformationa4</anchor>
      <arglist>(double value, double upper) const </arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>StackAllocator</name>
    <filename>classStackAllocator.html</filename>
    <member kind="enumvalue">
      <name>default_size</name>
      <anchor>StackAllocatorw1StackAllocatorw0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>StackAllocator</name>
      <anchor>StackAllocatora0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~StackAllocator</name>
      <anchor>StackAllocatora1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void *</type>
      <name>allocate</name>
      <anchor>StackAllocatora2</anchor>
      <arglist>(int nBytes)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>deallocate</name>
      <anchor>StackAllocatora3</anchor>
      <arglist>(void *p)</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>readInt</name>
      <anchor>StackAllocatora4</anchor>
      <arglist>(int offset)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>writeInt</name>
      <anchor>StackAllocatora5</anchor>
      <arglist>(int offset, int value)</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>toInt</name>
      <anchor>StackAllocatora6</anchor>
      <arglist>(void *p)</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>alignedSize</name>
      <anchor>StackAllocatora7</anchor>
      <arglist>(int nBytes)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>checkOverflow</name>
      <anchor>StackAllocatora8</anchor>
      <arglist>(int n)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>checkConsistency</name>
      <anchor>StackAllocatora9</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>unsigned char *</type>
      <name>theStack</name>
      <anchor>StackAllocatorr0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>theStackOffset</name>
      <anchor>StackAllocatorr1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>theBlockCount</name>
      <anchor>StackAllocatorr2</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>StackAllocatorHolder</name>
    <filename>classStackAllocatorHolder.html</filename>
    <member kind="function" static="yes">
      <type>StackAllocator &amp;</type>
      <name>get</name>
      <anchor>StackAllocatorHoldere0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>StackError</name>
    <filename>classStackError.html</filename>
  </compound>
  <compound kind="class">
    <name>StackOverflow</name>
    <filename>classStackOverflow.html</filename>
  </compound>
  <compound kind="class">
    <name>sym</name>
    <filename>classsym.html</filename>
  </compound>
  <compound kind="class">
    <name>VariableMetricBuilder</name>
    <filename>classVariableMetricBuilder.html</filename>
    <base>MinimumBuilder</base>
    <member kind="function">
      <type></type>
      <name>VariableMetricBuilder</name>
      <anchor>VariableMetricBuildera0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~VariableMetricBuilder</name>
      <anchor>VariableMetricBuildera1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual FunctionMinimum</type>
      <name>minimum</name>
      <anchor>VariableMetricBuildera2</anchor>
      <arglist>(const MnFcn &amp;, const GradientCalculator &amp;, const MinimumSeed &amp;, const MnStrategy &amp;, unsigned int, double) const </arglist>
    </member>
    <member kind="function">
      <type>FunctionMinimum</type>
      <name>minimum</name>
      <anchor>VariableMetricBuildera3</anchor>
      <arglist>(const MnFcn &amp;, const GradientCalculator &amp;, const MinimumSeed &amp;, unsigned int, double) const </arglist>
    </member>
    <member kind="function">
      <type>const VariableMetricEDMEstimator &amp;</type>
      <name>estimator</name>
      <anchor>VariableMetricBuildera4</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const DavidonErrorUpdator &amp;</type>
      <name>errorUpdator</name>
      <anchor>VariableMetricBuildera5</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="variable" protection="private">
      <type>VariableMetricEDMEstimator</type>
      <name>theEstimator</name>
      <anchor>VariableMetricBuilderr0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>DavidonErrorUpdator</type>
      <name>theErrorUpdator</name>
      <anchor>VariableMetricBuilderr1</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>VariableMetricEDMEstimator</name>
    <filename>classVariableMetricEDMEstimator.html</filename>
    <member kind="function">
      <type></type>
      <name>VariableMetricEDMEstimator</name>
      <anchor>VariableMetricEDMEstimatora0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~VariableMetricEDMEstimator</name>
      <anchor>VariableMetricEDMEstimatora1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>estimate</name>
      <anchor>VariableMetricEDMEstimatora2</anchor>
      <arglist>(const FunctionGradient &amp;, const MinimumError &amp;) const </arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>VariableMetricMinimizer</name>
    <filename>classVariableMetricMinimizer.html</filename>
    <base>ModularFunctionMinimizer</base>
    <member kind="function">
      <type></type>
      <name>VariableMetricMinimizer</name>
      <anchor>VariableMetricMinimizera0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~VariableMetricMinimizer</name>
      <anchor>VariableMetricMinimizera1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>const MinimumSeedGenerator &amp;</type>
      <name>seedGenerator</name>
      <anchor>VariableMetricMinimizera2</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const MinimumBuilder &amp;</type>
      <name>builder</name>
      <anchor>VariableMetricMinimizera3</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual FunctionMinimum</type>
      <name>minimize</name>
      <anchor>VariableMetricMinimizera4</anchor>
      <arglist>(const FCNBase &amp;, const std::vector&lt; double &gt; &amp;, const std::vector&lt; double &gt; &amp;, unsigned int stra=1, unsigned int maxfcn=0, double toler=0.1) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual FunctionMinimum</type>
      <name>minimize</name>
      <anchor>VariableMetricMinimizera5</anchor>
      <arglist>(const FCNGradientBase &amp;, const std::vector&lt; double &gt; &amp;, const std::vector&lt; double &gt; &amp;, unsigned int stra=1, unsigned int maxfcn=0, double toler=0.1) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual FunctionMinimum</type>
      <name>minimize</name>
      <anchor>VariableMetricMinimizera6</anchor>
      <arglist>(const FCNBase &amp;, const std::vector&lt; double &gt; &amp;, const std::vector&lt; double &gt; &amp;, unsigned int, unsigned int stra=1, unsigned int maxfcn=0, double toler=0.1) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual FunctionMinimum</type>
      <name>minimize</name>
      <anchor>VariableMetricMinimizera7</anchor>
      <arglist>(const FCNGradientBase &amp;, const std::vector&lt; double &gt; &amp;, const std::vector&lt; double &gt; &amp;, unsigned int, unsigned int stra=1, unsigned int maxfcn=0, double toler=0.1) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual FunctionMinimum</type>
      <name>minimize</name>
      <anchor>VariableMetricMinimizera8</anchor>
      <arglist>(const FCNBase &amp;, const MnUserParameters &amp;, const MnStrategy &amp;, unsigned int maxfcn=0, double toler=0.1) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual FunctionMinimum</type>
      <name>minimize</name>
      <anchor>VariableMetricMinimizera9</anchor>
      <arglist>(const FCNBase &amp;, const MnUserParameters &amp;, const MnUserCovariance &amp;, const MnStrategy &amp;, unsigned int maxfcn=0, double toler=0.1) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual FunctionMinimum</type>
      <name>minimize</name>
      <anchor>VariableMetricMinimizera10</anchor>
      <arglist>(const FCNBase &amp;, const MnUserParameterState &amp;, const MnStrategy &amp;, unsigned int maxfcn=0, double toler=0.1) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual FunctionMinimum</type>
      <name>minimize</name>
      <anchor>VariableMetricMinimizera11</anchor>
      <arglist>(const MnFcn &amp;, const GradientCalculator &amp;, const MinimumSeed &amp;, const MnStrategy &amp;, unsigned int, double) const </arglist>
    </member>
    <member kind="variable" protection="private">
      <type>MnSeedGenerator</type>
      <name>theMinSeedGen</name>
      <anchor>VariableMetricMinimizerr0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>VariableMetricBuilder</type>
      <name>theMinBuilder</name>
      <anchor>VariableMetricMinimizerr1</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>vec</name>
    <filename>classvec.html</filename>
  </compound>
  <compound kind="class">
    <name>VectorOuterProduct</name>
    <filename>classVectorOuterProduct.html</filename>
    <templarg>M</templarg>
    <templarg>T</templarg>
    <member kind="typedef">
      <type>sym</type>
      <name>Type</name>
      <anchor>VectorOuterProductw0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>VectorOuterProduct</name>
      <anchor>VectorOuterProducta0</anchor>
      <arglist>(const M &amp;obj)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~VectorOuterProduct</name>
      <anchor>VectorOuterProducta1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>const M &amp;</type>
      <name>obj</name>
      <anchor>VectorOuterProducta2</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="variable" protection="private">
      <type>M</type>
      <name>theObject</name>
      <anchor>VectorOuterProductr0</anchor>
      <arglist></arglist>
    </member>
  </compound>
</tagfile>
